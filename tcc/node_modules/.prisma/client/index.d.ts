
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Escola
 * 
 */
export type Escola = $Result.DefaultSelection<Prisma.$EscolaPayload>
/**
 * Model Turma
 * 
 */
export type Turma = $Result.DefaultSelection<Prisma.$TurmaPayload>
/**
 * Model tipoUsuario
 * 
 */
export type tipoUsuario = $Result.DefaultSelection<Prisma.$tipoUsuarioPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Atividade
 * 
 */
export type Atividade = $Result.DefaultSelection<Prisma.$AtividadePayload>
/**
 * Model tipoAtividade
 * 
 */
export type tipoAtividade = $Result.DefaultSelection<Prisma.$tipoAtividadePayload>
/**
 * Model Entrega
 * 
 */
export type Entrega = $Result.DefaultSelection<Prisma.$EntregaPayload>
/**
 * Model SolicitacaoSuporte
 * 
 */
export type SolicitacaoSuporte = $Result.DefaultSelection<Prisma.$SolicitacaoSuportePayload>
/**
 * Model Resposta
 * 
 */
export type Resposta = $Result.DefaultSelection<Prisma.$RespostaPayload>
/**
 * Model Correcao
 * 
 */
export type Correcao = $Result.DefaultSelection<Prisma.$CorrecaoPayload>
/**
 * Model Horas
 * 
 */
export type Horas = $Result.DefaultSelection<Prisma.$HorasPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Escolas
 * const escolas = await prisma.escola.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Escolas
   * const escolas = await prisma.escola.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.escola`: Exposes CRUD operations for the **Escola** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escolas
    * const escolas = await prisma.escola.findMany()
    * ```
    */
  get escola(): Prisma.EscolaDelegate<ExtArgs>;

  /**
   * `prisma.turma`: Exposes CRUD operations for the **Turma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Turmas
    * const turmas = await prisma.turma.findMany()
    * ```
    */
  get turma(): Prisma.TurmaDelegate<ExtArgs>;

  /**
   * `prisma.tipoUsuario`: Exposes CRUD operations for the **tipoUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoUsuarios
    * const tipoUsuarios = await prisma.tipoUsuario.findMany()
    * ```
    */
  get tipoUsuario(): Prisma.tipoUsuarioDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.atividade`: Exposes CRUD operations for the **Atividade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Atividades
    * const atividades = await prisma.atividade.findMany()
    * ```
    */
  get atividade(): Prisma.AtividadeDelegate<ExtArgs>;

  /**
   * `prisma.tipoAtividade`: Exposes CRUD operations for the **tipoAtividade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoAtividades
    * const tipoAtividades = await prisma.tipoAtividade.findMany()
    * ```
    */
  get tipoAtividade(): Prisma.tipoAtividadeDelegate<ExtArgs>;

  /**
   * `prisma.entrega`: Exposes CRUD operations for the **Entrega** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entregas
    * const entregas = await prisma.entrega.findMany()
    * ```
    */
  get entrega(): Prisma.EntregaDelegate<ExtArgs>;

  /**
   * `prisma.solicitacaoSuporte`: Exposes CRUD operations for the **SolicitacaoSuporte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SolicitacaoSuportes
    * const solicitacaoSuportes = await prisma.solicitacaoSuporte.findMany()
    * ```
    */
  get solicitacaoSuporte(): Prisma.SolicitacaoSuporteDelegate<ExtArgs>;

  /**
   * `prisma.resposta`: Exposes CRUD operations for the **Resposta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Respostas
    * const respostas = await prisma.resposta.findMany()
    * ```
    */
  get resposta(): Prisma.RespostaDelegate<ExtArgs>;

  /**
   * `prisma.correcao`: Exposes CRUD operations for the **Correcao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Correcaos
    * const correcaos = await prisma.correcao.findMany()
    * ```
    */
  get correcao(): Prisma.CorrecaoDelegate<ExtArgs>;

  /**
   * `prisma.horas`: Exposes CRUD operations for the **Horas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Horas
    * const horas = await prisma.horas.findMany()
    * ```
    */
  get horas(): Prisma.HorasDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.3.1
   * Query Engine version: 61e140623197a131c2a6189271ffee05a7aa9a59
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Escola: 'Escola',
    Turma: 'Turma',
    tipoUsuario: 'tipoUsuario',
    Usuario: 'Usuario',
    Atividade: 'Atividade',
    tipoAtividade: 'tipoAtividade',
    Entrega: 'Entrega',
    SolicitacaoSuporte: 'SolicitacaoSuporte',
    Resposta: 'Resposta',
    Correcao: 'Correcao',
    Horas: 'Horas'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'escola' | 'turma' | 'tipoUsuario' | 'usuario' | 'atividade' | 'tipoAtividade' | 'entrega' | 'solicitacaoSuporte' | 'resposta' | 'correcao' | 'horas'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Escola: {
        payload: Prisma.$EscolaPayload<ExtArgs>
        fields: Prisma.EscolaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EscolaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EscolaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          findFirst: {
            args: Prisma.EscolaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EscolaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          findMany: {
            args: Prisma.EscolaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>[]
          }
          create: {
            args: Prisma.EscolaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          createMany: {
            args: Prisma.EscolaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EscolaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          update: {
            args: Prisma.EscolaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          deleteMany: {
            args: Prisma.EscolaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EscolaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EscolaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EscolaPayload>
          }
          aggregate: {
            args: Prisma.EscolaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEscola>
          }
          groupBy: {
            args: Prisma.EscolaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EscolaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EscolaCountArgs<ExtArgs>,
            result: $Utils.Optional<EscolaCountAggregateOutputType> | number
          }
        }
      }
      Turma: {
        payload: Prisma.$TurmaPayload<ExtArgs>
        fields: Prisma.TurmaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TurmaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TurmaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          findFirst: {
            args: Prisma.TurmaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TurmaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          findMany: {
            args: Prisma.TurmaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>[]
          }
          create: {
            args: Prisma.TurmaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          createMany: {
            args: Prisma.TurmaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TurmaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          update: {
            args: Prisma.TurmaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          deleteMany: {
            args: Prisma.TurmaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TurmaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TurmaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TurmaPayload>
          }
          aggregate: {
            args: Prisma.TurmaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTurma>
          }
          groupBy: {
            args: Prisma.TurmaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TurmaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TurmaCountArgs<ExtArgs>,
            result: $Utils.Optional<TurmaCountAggregateOutputType> | number
          }
        }
      }
      tipoUsuario: {
        payload: Prisma.$tipoUsuarioPayload<ExtArgs>
        fields: Prisma.tipoUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoUsuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoUsuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload>
          }
          findFirst: {
            args: Prisma.tipoUsuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoUsuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload>
          }
          findMany: {
            args: Prisma.tipoUsuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload>[]
          }
          create: {
            args: Prisma.tipoUsuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload>
          }
          createMany: {
            args: Prisma.tipoUsuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tipoUsuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload>
          }
          update: {
            args: Prisma.tipoUsuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.tipoUsuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tipoUsuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tipoUsuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoUsuarioPayload>
          }
          aggregate: {
            args: Prisma.TipoUsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTipoUsuario>
          }
          groupBy: {
            args: Prisma.tipoUsuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TipoUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoUsuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<TipoUsuarioCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Atividade: {
        payload: Prisma.$AtividadePayload<ExtArgs>
        fields: Prisma.AtividadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AtividadeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AtividadeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload>
          }
          findFirst: {
            args: Prisma.AtividadeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AtividadeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload>
          }
          findMany: {
            args: Prisma.AtividadeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload>[]
          }
          create: {
            args: Prisma.AtividadeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload>
          }
          createMany: {
            args: Prisma.AtividadeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AtividadeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload>
          }
          update: {
            args: Prisma.AtividadeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload>
          }
          deleteMany: {
            args: Prisma.AtividadeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AtividadeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AtividadeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AtividadePayload>
          }
          aggregate: {
            args: Prisma.AtividadeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAtividade>
          }
          groupBy: {
            args: Prisma.AtividadeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AtividadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AtividadeCountArgs<ExtArgs>,
            result: $Utils.Optional<AtividadeCountAggregateOutputType> | number
          }
        }
      }
      tipoAtividade: {
        payload: Prisma.$tipoAtividadePayload<ExtArgs>
        fields: Prisma.tipoAtividadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoAtividadeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoAtividadeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload>
          }
          findFirst: {
            args: Prisma.tipoAtividadeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoAtividadeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload>
          }
          findMany: {
            args: Prisma.tipoAtividadeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload>[]
          }
          create: {
            args: Prisma.tipoAtividadeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload>
          }
          createMany: {
            args: Prisma.tipoAtividadeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.tipoAtividadeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload>
          }
          update: {
            args: Prisma.tipoAtividadeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload>
          }
          deleteMany: {
            args: Prisma.tipoAtividadeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.tipoAtividadeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.tipoAtividadeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$tipoAtividadePayload>
          }
          aggregate: {
            args: Prisma.TipoAtividadeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTipoAtividade>
          }
          groupBy: {
            args: Prisma.tipoAtividadeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TipoAtividadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoAtividadeCountArgs<ExtArgs>,
            result: $Utils.Optional<TipoAtividadeCountAggregateOutputType> | number
          }
        }
      }
      Entrega: {
        payload: Prisma.$EntregaPayload<ExtArgs>
        fields: Prisma.EntregaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntregaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntregaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload>
          }
          findFirst: {
            args: Prisma.EntregaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntregaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload>
          }
          findMany: {
            args: Prisma.EntregaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload>[]
          }
          create: {
            args: Prisma.EntregaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload>
          }
          createMany: {
            args: Prisma.EntregaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EntregaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload>
          }
          update: {
            args: Prisma.EntregaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload>
          }
          deleteMany: {
            args: Prisma.EntregaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EntregaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EntregaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EntregaPayload>
          }
          aggregate: {
            args: Prisma.EntregaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEntrega>
          }
          groupBy: {
            args: Prisma.EntregaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EntregaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntregaCountArgs<ExtArgs>,
            result: $Utils.Optional<EntregaCountAggregateOutputType> | number
          }
        }
      }
      SolicitacaoSuporte: {
        payload: Prisma.$SolicitacaoSuportePayload<ExtArgs>
        fields: Prisma.SolicitacaoSuporteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SolicitacaoSuporteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SolicitacaoSuporteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload>
          }
          findFirst: {
            args: Prisma.SolicitacaoSuporteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SolicitacaoSuporteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload>
          }
          findMany: {
            args: Prisma.SolicitacaoSuporteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload>[]
          }
          create: {
            args: Prisma.SolicitacaoSuporteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload>
          }
          createMany: {
            args: Prisma.SolicitacaoSuporteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SolicitacaoSuporteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload>
          }
          update: {
            args: Prisma.SolicitacaoSuporteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload>
          }
          deleteMany: {
            args: Prisma.SolicitacaoSuporteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SolicitacaoSuporteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SolicitacaoSuporteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SolicitacaoSuportePayload>
          }
          aggregate: {
            args: Prisma.SolicitacaoSuporteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSolicitacaoSuporte>
          }
          groupBy: {
            args: Prisma.SolicitacaoSuporteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SolicitacaoSuporteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SolicitacaoSuporteCountArgs<ExtArgs>,
            result: $Utils.Optional<SolicitacaoSuporteCountAggregateOutputType> | number
          }
        }
      }
      Resposta: {
        payload: Prisma.$RespostaPayload<ExtArgs>
        fields: Prisma.RespostaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RespostaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RespostaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload>
          }
          findFirst: {
            args: Prisma.RespostaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RespostaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload>
          }
          findMany: {
            args: Prisma.RespostaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload>[]
          }
          create: {
            args: Prisma.RespostaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload>
          }
          createMany: {
            args: Prisma.RespostaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RespostaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload>
          }
          update: {
            args: Prisma.RespostaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload>
          }
          deleteMany: {
            args: Prisma.RespostaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RespostaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RespostaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RespostaPayload>
          }
          aggregate: {
            args: Prisma.RespostaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResposta>
          }
          groupBy: {
            args: Prisma.RespostaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RespostaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RespostaCountArgs<ExtArgs>,
            result: $Utils.Optional<RespostaCountAggregateOutputType> | number
          }
        }
      }
      Correcao: {
        payload: Prisma.$CorrecaoPayload<ExtArgs>
        fields: Prisma.CorrecaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorrecaoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorrecaoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload>
          }
          findFirst: {
            args: Prisma.CorrecaoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorrecaoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload>
          }
          findMany: {
            args: Prisma.CorrecaoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload>[]
          }
          create: {
            args: Prisma.CorrecaoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload>
          }
          createMany: {
            args: Prisma.CorrecaoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CorrecaoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload>
          }
          update: {
            args: Prisma.CorrecaoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload>
          }
          deleteMany: {
            args: Prisma.CorrecaoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CorrecaoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CorrecaoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CorrecaoPayload>
          }
          aggregate: {
            args: Prisma.CorrecaoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCorrecao>
          }
          groupBy: {
            args: Prisma.CorrecaoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CorrecaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorrecaoCountArgs<ExtArgs>,
            result: $Utils.Optional<CorrecaoCountAggregateOutputType> | number
          }
        }
      }
      Horas: {
        payload: Prisma.$HorasPayload<ExtArgs>
        fields: Prisma.HorasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HorasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HorasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload>
          }
          findFirst: {
            args: Prisma.HorasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HorasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload>
          }
          findMany: {
            args: Prisma.HorasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload>[]
          }
          create: {
            args: Prisma.HorasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload>
          }
          createMany: {
            args: Prisma.HorasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HorasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload>
          }
          update: {
            args: Prisma.HorasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload>
          }
          deleteMany: {
            args: Prisma.HorasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HorasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HorasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HorasPayload>
          }
          aggregate: {
            args: Prisma.HorasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHoras>
          }
          groupBy: {
            args: Prisma.HorasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HorasGroupByOutputType>[]
          }
          count: {
            args: Prisma.HorasCountArgs<ExtArgs>,
            result: $Utils.Optional<HorasCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EscolaCountOutputType
   */

  export type EscolaCountOutputType = {
    Usuario: number
    Turma: number
  }

  export type EscolaCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Usuario?: boolean | EscolaCountOutputTypeCountUsuarioArgs
    Turma?: boolean | EscolaCountOutputTypeCountTurmaArgs
  }

  // Custom InputTypes

  /**
   * EscolaCountOutputType without action
   */
  export type EscolaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaCountOutputType
     */
    select?: EscolaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EscolaCountOutputType without action
   */
  export type EscolaCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * EscolaCountOutputType without action
   */
  export type EscolaCountOutputTypeCountTurmaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TurmaWhereInput
  }



  /**
   * Count Type TurmaCountOutputType
   */

  export type TurmaCountOutputType = {
    Usuario: number
  }

  export type TurmaCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Usuario?: boolean | TurmaCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes

  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TurmaCountOutputType
     */
    select?: TurmaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TurmaCountOutputType without action
   */
  export type TurmaCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }



  /**
   * Count Type TipoUsuarioCountOutputType
   */

  export type TipoUsuarioCountOutputType = {
    Usuario: number
  }

  export type TipoUsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Usuario?: boolean | TipoUsuarioCountOutputTypeCountUsuarioArgs
  }

  // Custom InputTypes

  /**
   * TipoUsuarioCountOutputType without action
   */
  export type TipoUsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoUsuarioCountOutputType
     */
    select?: TipoUsuarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TipoUsuarioCountOutputType without action
   */
  export type TipoUsuarioCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }



  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    Entrega: number
    SolicitacaoSuporte: number
    Resposta: number
    Correcao: number
    Horas: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Entrega?: boolean | UsuarioCountOutputTypeCountEntregaArgs
    SolicitacaoSuporte?: boolean | UsuarioCountOutputTypeCountSolicitacaoSuporteArgs
    Resposta?: boolean | UsuarioCountOutputTypeCountRespostaArgs
    Correcao?: boolean | UsuarioCountOutputTypeCountCorrecaoArgs
    Horas?: boolean | UsuarioCountOutputTypeCountHorasArgs
  }

  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEntregaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EntregaWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountSolicitacaoSuporteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SolicitacaoSuporteWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRespostaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RespostaWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCorrecaoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CorrecaoWhereInput
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountHorasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: HorasWhereInput
  }



  /**
   * Count Type AtividadeCountOutputType
   */

  export type AtividadeCountOutputType = {
    entrega: number
  }

  export type AtividadeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    entrega?: boolean | AtividadeCountOutputTypeCountEntregaArgs
  }

  // Custom InputTypes

  /**
   * AtividadeCountOutputType without action
   */
  export type AtividadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AtividadeCountOutputType
     */
    select?: AtividadeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AtividadeCountOutputType without action
   */
  export type AtividadeCountOutputTypeCountEntregaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EntregaWhereInput
  }



  /**
   * Count Type TipoAtividadeCountOutputType
   */

  export type TipoAtividadeCountOutputType = {
    Atividade: number
  }

  export type TipoAtividadeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Atividade?: boolean | TipoAtividadeCountOutputTypeCountAtividadeArgs
  }

  // Custom InputTypes

  /**
   * TipoAtividadeCountOutputType without action
   */
  export type TipoAtividadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAtividadeCountOutputType
     */
    select?: TipoAtividadeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TipoAtividadeCountOutputType without action
   */
  export type TipoAtividadeCountOutputTypeCountAtividadeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AtividadeWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Escola
   */

  export type AggregateEscola = {
    _count: EscolaCountAggregateOutputType | null
    _avg: EscolaAvgAggregateOutputType | null
    _sum: EscolaSumAggregateOutputType | null
    _min: EscolaMinAggregateOutputType | null
    _max: EscolaMaxAggregateOutputType | null
  }

  export type EscolaAvgAggregateOutputType = {
    id: number | null
  }

  export type EscolaSumAggregateOutputType = {
    id: number | null
  }

  export type EscolaMinAggregateOutputType = {
    id: number | null
    nomeEscola: string | null
  }

  export type EscolaMaxAggregateOutputType = {
    id: number | null
    nomeEscola: string | null
  }

  export type EscolaCountAggregateOutputType = {
    id: number
    nomeEscola: number
    _all: number
  }


  export type EscolaAvgAggregateInputType = {
    id?: true
  }

  export type EscolaSumAggregateInputType = {
    id?: true
  }

  export type EscolaMinAggregateInputType = {
    id?: true
    nomeEscola?: true
  }

  export type EscolaMaxAggregateInputType = {
    id?: true
    nomeEscola?: true
  }

  export type EscolaCountAggregateInputType = {
    id?: true
    nomeEscola?: true
    _all?: true
  }

  export type EscolaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escola to aggregate.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Escolas
    **/
    _count?: true | EscolaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscolaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscolaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscolaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscolaMaxAggregateInputType
  }

  export type GetEscolaAggregateType<T extends EscolaAggregateArgs> = {
        [P in keyof T & keyof AggregateEscola]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscola[P]>
      : GetScalarType<T[P], AggregateEscola[P]>
  }




  export type EscolaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EscolaWhereInput
    orderBy?: EscolaOrderByWithAggregationInput | EscolaOrderByWithAggregationInput[]
    by: EscolaScalarFieldEnum[] | EscolaScalarFieldEnum
    having?: EscolaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscolaCountAggregateInputType | true
    _avg?: EscolaAvgAggregateInputType
    _sum?: EscolaSumAggregateInputType
    _min?: EscolaMinAggregateInputType
    _max?: EscolaMaxAggregateInputType
  }

  export type EscolaGroupByOutputType = {
    id: number
    nomeEscola: string
    _count: EscolaCountAggregateOutputType | null
    _avg: EscolaAvgAggregateOutputType | null
    _sum: EscolaSumAggregateOutputType | null
    _min: EscolaMinAggregateOutputType | null
    _max: EscolaMaxAggregateOutputType | null
  }

  type GetEscolaGroupByPayload<T extends EscolaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscolaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscolaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscolaGroupByOutputType[P]>
            : GetScalarType<T[P], EscolaGroupByOutputType[P]>
        }
      >
    >


  export type EscolaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nomeEscola?: boolean
    Usuario?: boolean | Escola$UsuarioArgs<ExtArgs>
    Turma?: boolean | Escola$TurmaArgs<ExtArgs>
    _count?: boolean | EscolaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escola"]>

  export type EscolaSelectScalar = {
    id?: boolean
    nomeEscola?: boolean
  }

  export type EscolaInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Usuario?: boolean | Escola$UsuarioArgs<ExtArgs>
    Turma?: boolean | Escola$TurmaArgs<ExtArgs>
    _count?: boolean | EscolaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EscolaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Escola"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>[]
      Turma: Prisma.$TurmaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      nomeEscola: string
    }, ExtArgs["result"]["escola"]>
    composites: {}
  }


  type EscolaGetPayload<S extends boolean | null | undefined | EscolaDefaultArgs> = $Result.GetResult<Prisma.$EscolaPayload, S>

  type EscolaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EscolaFindManyArgs, 'select' | 'include'> & {
      select?: EscolaCountAggregateInputType | true
    }

  export interface EscolaDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Escola'], meta: { name: 'Escola' } }
    /**
     * Find zero or one Escola that matches the filter.
     * @param {EscolaFindUniqueArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EscolaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EscolaFindUniqueArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Escola that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EscolaFindUniqueOrThrowArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EscolaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EscolaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Escola that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaFindFirstArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EscolaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EscolaFindFirstArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Escola that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaFindFirstOrThrowArgs} args - Arguments to find a Escola
     * @example
     * // Get one Escola
     * const escola = await prisma.escola.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EscolaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EscolaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Escolas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escolas
     * const escolas = await prisma.escola.findMany()
     * 
     * // Get first 10 Escolas
     * const escolas = await prisma.escola.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escolaWithIdOnly = await prisma.escola.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EscolaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EscolaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Escola.
     * @param {EscolaCreateArgs} args - Arguments to create a Escola.
     * @example
     * // Create one Escola
     * const Escola = await prisma.escola.create({
     *   data: {
     *     // ... data to create a Escola
     *   }
     * })
     * 
    **/
    create<T extends EscolaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EscolaCreateArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Escolas.
     *     @param {EscolaCreateManyArgs} args - Arguments to create many Escolas.
     *     @example
     *     // Create many Escolas
     *     const escola = await prisma.escola.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EscolaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EscolaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Escola.
     * @param {EscolaDeleteArgs} args - Arguments to delete one Escola.
     * @example
     * // Delete one Escola
     * const Escola = await prisma.escola.delete({
     *   where: {
     *     // ... filter to delete one Escola
     *   }
     * })
     * 
    **/
    delete<T extends EscolaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EscolaDeleteArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Escola.
     * @param {EscolaUpdateArgs} args - Arguments to update one Escola.
     * @example
     * // Update one Escola
     * const escola = await prisma.escola.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EscolaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EscolaUpdateArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Escolas.
     * @param {EscolaDeleteManyArgs} args - Arguments to filter Escolas to delete.
     * @example
     * // Delete a few Escolas
     * const { count } = await prisma.escola.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EscolaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EscolaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escolas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escolas
     * const escola = await prisma.escola.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EscolaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EscolaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Escola.
     * @param {EscolaUpsertArgs} args - Arguments to update or create a Escola.
     * @example
     * // Update or create a Escola
     * const escola = await prisma.escola.upsert({
     *   create: {
     *     // ... data to create a Escola
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escola we want to update
     *   }
     * })
    **/
    upsert<T extends EscolaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EscolaUpsertArgs<ExtArgs>>
    ): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Escolas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaCountArgs} args - Arguments to filter Escolas to count.
     * @example
     * // Count the number of Escolas
     * const count = await prisma.escola.count({
     *   where: {
     *     // ... the filter for the Escolas we want to count
     *   }
     * })
    **/
    count<T extends EscolaCountArgs>(
      args?: Subset<T, EscolaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscolaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escola.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscolaAggregateArgs>(args: Subset<T, EscolaAggregateArgs>): Prisma.PrismaPromise<GetEscolaAggregateType<T>>

    /**
     * Group by Escola.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EscolaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EscolaGroupByArgs['orderBy'] }
        : { orderBy?: EscolaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EscolaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscolaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Escola model
   */
  readonly fields: EscolaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Escola.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EscolaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuario<T extends Escola$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Escola$UsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    Turma<T extends Escola$TurmaArgs<ExtArgs> = {}>(args?: Subset<T, Escola$TurmaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Escola model
   */ 
  interface EscolaFieldRefs {
    readonly id: FieldRef<"Escola", 'Int'>
    readonly nomeEscola: FieldRef<"Escola", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Escola findUnique
   */
  export type EscolaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where: EscolaWhereUniqueInput
  }


  /**
   * Escola findUniqueOrThrow
   */
  export type EscolaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where: EscolaWhereUniqueInput
  }


  /**
   * Escola findFirst
   */
  export type EscolaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escolas.
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escolas.
     */
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }


  /**
   * Escola findFirstOrThrow
   */
  export type EscolaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escola to fetch.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Escolas.
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Escolas.
     */
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }


  /**
   * Escola findMany
   */
  export type EscolaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter, which Escolas to fetch.
     */
    where?: EscolaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Escolas to fetch.
     */
    orderBy?: EscolaOrderByWithRelationInput | EscolaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Escolas.
     */
    cursor?: EscolaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Escolas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Escolas.
     */
    skip?: number
    distinct?: EscolaScalarFieldEnum | EscolaScalarFieldEnum[]
  }


  /**
   * Escola create
   */
  export type EscolaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * The data needed to create a Escola.
     */
    data: XOR<EscolaCreateInput, EscolaUncheckedCreateInput>
  }


  /**
   * Escola createMany
   */
  export type EscolaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Escolas.
     */
    data: EscolaCreateManyInput | EscolaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Escola update
   */
  export type EscolaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * The data needed to update a Escola.
     */
    data: XOR<EscolaUpdateInput, EscolaUncheckedUpdateInput>
    /**
     * Choose, which Escola to update.
     */
    where: EscolaWhereUniqueInput
  }


  /**
   * Escola updateMany
   */
  export type EscolaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Escolas.
     */
    data: XOR<EscolaUpdateManyMutationInput, EscolaUncheckedUpdateManyInput>
    /**
     * Filter which Escolas to update
     */
    where?: EscolaWhereInput
  }


  /**
   * Escola upsert
   */
  export type EscolaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * The filter to search for the Escola to update in case it exists.
     */
    where: EscolaWhereUniqueInput
    /**
     * In case the Escola found by the `where` argument doesn't exist, create a new Escola with this data.
     */
    create: XOR<EscolaCreateInput, EscolaUncheckedCreateInput>
    /**
     * In case the Escola was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EscolaUpdateInput, EscolaUncheckedUpdateInput>
  }


  /**
   * Escola delete
   */
  export type EscolaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    /**
     * Filter which Escola to delete.
     */
    where: EscolaWhereUniqueInput
  }


  /**
   * Escola deleteMany
   */
  export type EscolaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Escolas to delete
     */
    where?: EscolaWhereInput
  }


  /**
   * Escola.Usuario
   */
  export type Escola$UsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Escola.Turma
   */
  export type Escola$TurmaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    where?: TurmaWhereInput
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    cursor?: TurmaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }


  /**
   * Escola without action
   */
  export type EscolaDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
  }



  /**
   * Model Turma
   */

  export type AggregateTurma = {
    _count: TurmaCountAggregateOutputType | null
    _avg: TurmaAvgAggregateOutputType | null
    _sum: TurmaSumAggregateOutputType | null
    _min: TurmaMinAggregateOutputType | null
    _max: TurmaMaxAggregateOutputType | null
  }

  export type TurmaAvgAggregateOutputType = {
    id: number | null
    ano: number | null
    codEscola: number | null
  }

  export type TurmaSumAggregateOutputType = {
    id: number | null
    ano: number | null
    codEscola: number | null
  }

  export type TurmaMinAggregateOutputType = {
    id: number | null
    ano: number | null
    nomeTurma: string | null
    codEscola: number | null
  }

  export type TurmaMaxAggregateOutputType = {
    id: number | null
    ano: number | null
    nomeTurma: string | null
    codEscola: number | null
  }

  export type TurmaCountAggregateOutputType = {
    id: number
    ano: number
    nomeTurma: number
    codEscola: number
    _all: number
  }


  export type TurmaAvgAggregateInputType = {
    id?: true
    ano?: true
    codEscola?: true
  }

  export type TurmaSumAggregateInputType = {
    id?: true
    ano?: true
    codEscola?: true
  }

  export type TurmaMinAggregateInputType = {
    id?: true
    ano?: true
    nomeTurma?: true
    codEscola?: true
  }

  export type TurmaMaxAggregateInputType = {
    id?: true
    ano?: true
    nomeTurma?: true
    codEscola?: true
  }

  export type TurmaCountAggregateInputType = {
    id?: true
    ano?: true
    nomeTurma?: true
    codEscola?: true
    _all?: true
  }

  export type TurmaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Turma to aggregate.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Turmas
    **/
    _count?: true | TurmaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TurmaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TurmaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TurmaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TurmaMaxAggregateInputType
  }

  export type GetTurmaAggregateType<T extends TurmaAggregateArgs> = {
        [P in keyof T & keyof AggregateTurma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTurma[P]>
      : GetScalarType<T[P], AggregateTurma[P]>
  }




  export type TurmaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TurmaWhereInput
    orderBy?: TurmaOrderByWithAggregationInput | TurmaOrderByWithAggregationInput[]
    by: TurmaScalarFieldEnum[] | TurmaScalarFieldEnum
    having?: TurmaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TurmaCountAggregateInputType | true
    _avg?: TurmaAvgAggregateInputType
    _sum?: TurmaSumAggregateInputType
    _min?: TurmaMinAggregateInputType
    _max?: TurmaMaxAggregateInputType
  }

  export type TurmaGroupByOutputType = {
    id: number
    ano: number
    nomeTurma: string
    codEscola: number
    _count: TurmaCountAggregateOutputType | null
    _avg: TurmaAvgAggregateOutputType | null
    _sum: TurmaSumAggregateOutputType | null
    _min: TurmaMinAggregateOutputType | null
    _max: TurmaMaxAggregateOutputType | null
  }

  type GetTurmaGroupByPayload<T extends TurmaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TurmaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TurmaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TurmaGroupByOutputType[P]>
            : GetScalarType<T[P], TurmaGroupByOutputType[P]>
        }
      >
    >


  export type TurmaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ano?: boolean
    nomeTurma?: boolean
    codEscola?: boolean
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    Usuario?: boolean | Turma$UsuarioArgs<ExtArgs>
    _count?: boolean | TurmaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["turma"]>

  export type TurmaSelectScalar = {
    id?: boolean
    ano?: boolean
    nomeTurma?: boolean
    codEscola?: boolean
  }

  export type TurmaInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    escola?: boolean | EscolaDefaultArgs<ExtArgs>
    Usuario?: boolean | Turma$UsuarioArgs<ExtArgs>
    _count?: boolean | TurmaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TurmaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Turma"
    objects: {
      escola: Prisma.$EscolaPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      ano: number
      nomeTurma: string
      codEscola: number
    }, ExtArgs["result"]["turma"]>
    composites: {}
  }


  type TurmaGetPayload<S extends boolean | null | undefined | TurmaDefaultArgs> = $Result.GetResult<Prisma.$TurmaPayload, S>

  type TurmaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TurmaFindManyArgs, 'select' | 'include'> & {
      select?: TurmaCountAggregateInputType | true
    }

  export interface TurmaDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Turma'], meta: { name: 'Turma' } }
    /**
     * Find zero or one Turma that matches the filter.
     * @param {TurmaFindUniqueArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TurmaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TurmaFindUniqueArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Turma that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TurmaFindUniqueOrThrowArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TurmaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TurmaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Turma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaFindFirstArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TurmaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TurmaFindFirstArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Turma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaFindFirstOrThrowArgs} args - Arguments to find a Turma
     * @example
     * // Get one Turma
     * const turma = await prisma.turma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TurmaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TurmaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Turmas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Turmas
     * const turmas = await prisma.turma.findMany()
     * 
     * // Get first 10 Turmas
     * const turmas = await prisma.turma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const turmaWithIdOnly = await prisma.turma.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TurmaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TurmaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Turma.
     * @param {TurmaCreateArgs} args - Arguments to create a Turma.
     * @example
     * // Create one Turma
     * const Turma = await prisma.turma.create({
     *   data: {
     *     // ... data to create a Turma
     *   }
     * })
     * 
    **/
    create<T extends TurmaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TurmaCreateArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Turmas.
     *     @param {TurmaCreateManyArgs} args - Arguments to create many Turmas.
     *     @example
     *     // Create many Turmas
     *     const turma = await prisma.turma.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TurmaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TurmaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Turma.
     * @param {TurmaDeleteArgs} args - Arguments to delete one Turma.
     * @example
     * // Delete one Turma
     * const Turma = await prisma.turma.delete({
     *   where: {
     *     // ... filter to delete one Turma
     *   }
     * })
     * 
    **/
    delete<T extends TurmaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TurmaDeleteArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Turma.
     * @param {TurmaUpdateArgs} args - Arguments to update one Turma.
     * @example
     * // Update one Turma
     * const turma = await prisma.turma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TurmaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TurmaUpdateArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Turmas.
     * @param {TurmaDeleteManyArgs} args - Arguments to filter Turmas to delete.
     * @example
     * // Delete a few Turmas
     * const { count } = await prisma.turma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TurmaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TurmaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Turmas
     * const turma = await prisma.turma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TurmaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TurmaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Turma.
     * @param {TurmaUpsertArgs} args - Arguments to update or create a Turma.
     * @example
     * // Update or create a Turma
     * const turma = await prisma.turma.upsert({
     *   create: {
     *     // ... data to create a Turma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Turma we want to update
     *   }
     * })
    **/
    upsert<T extends TurmaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TurmaUpsertArgs<ExtArgs>>
    ): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Turmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaCountArgs} args - Arguments to filter Turmas to count.
     * @example
     * // Count the number of Turmas
     * const count = await prisma.turma.count({
     *   where: {
     *     // ... the filter for the Turmas we want to count
     *   }
     * })
    **/
    count<T extends TurmaCountArgs>(
      args?: Subset<T, TurmaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TurmaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Turma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TurmaAggregateArgs>(args: Subset<T, TurmaAggregateArgs>): Prisma.PrismaPromise<GetTurmaAggregateType<T>>

    /**
     * Group by Turma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TurmaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TurmaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TurmaGroupByArgs['orderBy'] }
        : { orderBy?: TurmaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TurmaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTurmaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Turma model
   */
  readonly fields: TurmaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Turma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TurmaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    escola<T extends EscolaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EscolaDefaultArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Usuario<T extends Turma$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Turma$UsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Turma model
   */ 
  interface TurmaFieldRefs {
    readonly id: FieldRef<"Turma", 'Int'>
    readonly ano: FieldRef<"Turma", 'Int'>
    readonly nomeTurma: FieldRef<"Turma", 'String'>
    readonly codEscola: FieldRef<"Turma", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Turma findUnique
   */
  export type TurmaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where: TurmaWhereUniqueInput
  }


  /**
   * Turma findUniqueOrThrow
   */
  export type TurmaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where: TurmaWhereUniqueInput
  }


  /**
   * Turma findFirst
   */
  export type TurmaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Turmas.
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Turmas.
     */
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }


  /**
   * Turma findFirstOrThrow
   */
  export type TurmaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turma to fetch.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Turmas.
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Turmas.
     */
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }


  /**
   * Turma findMany
   */
  export type TurmaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter, which Turmas to fetch.
     */
    where?: TurmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turmas to fetch.
     */
    orderBy?: TurmaOrderByWithRelationInput | TurmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Turmas.
     */
    cursor?: TurmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turmas.
     */
    skip?: number
    distinct?: TurmaScalarFieldEnum | TurmaScalarFieldEnum[]
  }


  /**
   * Turma create
   */
  export type TurmaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * The data needed to create a Turma.
     */
    data: XOR<TurmaCreateInput, TurmaUncheckedCreateInput>
  }


  /**
   * Turma createMany
   */
  export type TurmaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Turmas.
     */
    data: TurmaCreateManyInput | TurmaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Turma update
   */
  export type TurmaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * The data needed to update a Turma.
     */
    data: XOR<TurmaUpdateInput, TurmaUncheckedUpdateInput>
    /**
     * Choose, which Turma to update.
     */
    where: TurmaWhereUniqueInput
  }


  /**
   * Turma updateMany
   */
  export type TurmaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Turmas.
     */
    data: XOR<TurmaUpdateManyMutationInput, TurmaUncheckedUpdateManyInput>
    /**
     * Filter which Turmas to update
     */
    where?: TurmaWhereInput
  }


  /**
   * Turma upsert
   */
  export type TurmaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * The filter to search for the Turma to update in case it exists.
     */
    where: TurmaWhereUniqueInput
    /**
     * In case the Turma found by the `where` argument doesn't exist, create a new Turma with this data.
     */
    create: XOR<TurmaCreateInput, TurmaUncheckedCreateInput>
    /**
     * In case the Turma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TurmaUpdateInput, TurmaUncheckedUpdateInput>
  }


  /**
   * Turma delete
   */
  export type TurmaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    /**
     * Filter which Turma to delete.
     */
    where: TurmaWhereUniqueInput
  }


  /**
   * Turma deleteMany
   */
  export type TurmaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Turmas to delete
     */
    where?: TurmaWhereInput
  }


  /**
   * Turma.Usuario
   */
  export type Turma$UsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Turma without action
   */
  export type TurmaDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
  }



  /**
   * Model tipoUsuario
   */

  export type AggregateTipoUsuario = {
    _count: TipoUsuarioCountAggregateOutputType | null
    _avg: TipoUsuarioAvgAggregateOutputType | null
    _sum: TipoUsuarioSumAggregateOutputType | null
    _min: TipoUsuarioMinAggregateOutputType | null
    _max: TipoUsuarioMaxAggregateOutputType | null
  }

  export type TipoUsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoUsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type TipoUsuarioMinAggregateOutputType = {
    id: number | null
    tipoUsuario: string | null
  }

  export type TipoUsuarioMaxAggregateOutputType = {
    id: number | null
    tipoUsuario: string | null
  }

  export type TipoUsuarioCountAggregateOutputType = {
    id: number
    tipoUsuario: number
    _all: number
  }


  export type TipoUsuarioAvgAggregateInputType = {
    id?: true
  }

  export type TipoUsuarioSumAggregateInputType = {
    id?: true
  }

  export type TipoUsuarioMinAggregateInputType = {
    id?: true
    tipoUsuario?: true
  }

  export type TipoUsuarioMaxAggregateInputType = {
    id?: true
    tipoUsuario?: true
  }

  export type TipoUsuarioCountAggregateInputType = {
    id?: true
    tipoUsuario?: true
    _all?: true
  }

  export type TipoUsuarioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoUsuario to aggregate.
     */
    where?: tipoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoUsuarios to fetch.
     */
    orderBy?: tipoUsuarioOrderByWithRelationInput | tipoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoUsuarios
    **/
    _count?: true | TipoUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoUsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoUsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoUsuarioMaxAggregateInputType
  }

  export type GetTipoUsuarioAggregateType<T extends TipoUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoUsuario[P]>
      : GetScalarType<T[P], AggregateTipoUsuario[P]>
  }




  export type tipoUsuarioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tipoUsuarioWhereInput
    orderBy?: tipoUsuarioOrderByWithAggregationInput | tipoUsuarioOrderByWithAggregationInput[]
    by: TipoUsuarioScalarFieldEnum[] | TipoUsuarioScalarFieldEnum
    having?: tipoUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoUsuarioCountAggregateInputType | true
    _avg?: TipoUsuarioAvgAggregateInputType
    _sum?: TipoUsuarioSumAggregateInputType
    _min?: TipoUsuarioMinAggregateInputType
    _max?: TipoUsuarioMaxAggregateInputType
  }

  export type TipoUsuarioGroupByOutputType = {
    id: number
    tipoUsuario: string
    _count: TipoUsuarioCountAggregateOutputType | null
    _avg: TipoUsuarioAvgAggregateOutputType | null
    _sum: TipoUsuarioSumAggregateOutputType | null
    _min: TipoUsuarioMinAggregateOutputType | null
    _max: TipoUsuarioMaxAggregateOutputType | null
  }

  type GetTipoUsuarioGroupByPayload<T extends tipoUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], TipoUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type tipoUsuarioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoUsuario?: boolean
    Usuario?: boolean | tipoUsuario$UsuarioArgs<ExtArgs>
    _count?: boolean | TipoUsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoUsuario"]>

  export type tipoUsuarioSelectScalar = {
    id?: boolean
    tipoUsuario?: boolean
  }

  export type tipoUsuarioInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Usuario?: boolean | tipoUsuario$UsuarioArgs<ExtArgs>
    _count?: boolean | TipoUsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tipoUsuarioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "tipoUsuario"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      tipoUsuario: string
    }, ExtArgs["result"]["tipoUsuario"]>
    composites: {}
  }


  type tipoUsuarioGetPayload<S extends boolean | null | undefined | tipoUsuarioDefaultArgs> = $Result.GetResult<Prisma.$tipoUsuarioPayload, S>

  type tipoUsuarioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tipoUsuarioFindManyArgs, 'select' | 'include'> & {
      select?: TipoUsuarioCountAggregateInputType | true
    }

  export interface tipoUsuarioDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoUsuario'], meta: { name: 'tipoUsuario' } }
    /**
     * Find zero or one TipoUsuario that matches the filter.
     * @param {tipoUsuarioFindUniqueArgs} args - Arguments to find a TipoUsuario
     * @example
     * // Get one TipoUsuario
     * const tipoUsuario = await prisma.tipoUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tipoUsuarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tipoUsuarioFindUniqueArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TipoUsuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tipoUsuarioFindUniqueOrThrowArgs} args - Arguments to find a TipoUsuario
     * @example
     * // Get one TipoUsuario
     * const tipoUsuario = await prisma.tipoUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tipoUsuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoUsuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TipoUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoUsuarioFindFirstArgs} args - Arguments to find a TipoUsuario
     * @example
     * // Get one TipoUsuario
     * const tipoUsuario = await prisma.tipoUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tipoUsuarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoUsuarioFindFirstArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TipoUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoUsuarioFindFirstOrThrowArgs} args - Arguments to find a TipoUsuario
     * @example
     * // Get one TipoUsuario
     * const tipoUsuario = await prisma.tipoUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tipoUsuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoUsuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TipoUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoUsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoUsuarios
     * const tipoUsuarios = await prisma.tipoUsuario.findMany()
     * 
     * // Get first 10 TipoUsuarios
     * const tipoUsuarios = await prisma.tipoUsuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoUsuarioWithIdOnly = await prisma.tipoUsuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tipoUsuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoUsuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TipoUsuario.
     * @param {tipoUsuarioCreateArgs} args - Arguments to create a TipoUsuario.
     * @example
     * // Create one TipoUsuario
     * const TipoUsuario = await prisma.tipoUsuario.create({
     *   data: {
     *     // ... data to create a TipoUsuario
     *   }
     * })
     * 
    **/
    create<T extends tipoUsuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tipoUsuarioCreateArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TipoUsuarios.
     *     @param {tipoUsuarioCreateManyArgs} args - Arguments to create many TipoUsuarios.
     *     @example
     *     // Create many TipoUsuarios
     *     const tipoUsuario = await prisma.tipoUsuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tipoUsuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoUsuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TipoUsuario.
     * @param {tipoUsuarioDeleteArgs} args - Arguments to delete one TipoUsuario.
     * @example
     * // Delete one TipoUsuario
     * const TipoUsuario = await prisma.tipoUsuario.delete({
     *   where: {
     *     // ... filter to delete one TipoUsuario
     *   }
     * })
     * 
    **/
    delete<T extends tipoUsuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tipoUsuarioDeleteArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TipoUsuario.
     * @param {tipoUsuarioUpdateArgs} args - Arguments to update one TipoUsuario.
     * @example
     * // Update one TipoUsuario
     * const tipoUsuario = await prisma.tipoUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tipoUsuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tipoUsuarioUpdateArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TipoUsuarios.
     * @param {tipoUsuarioDeleteManyArgs} args - Arguments to filter TipoUsuarios to delete.
     * @example
     * // Delete a few TipoUsuarios
     * const { count } = await prisma.tipoUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tipoUsuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoUsuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoUsuarios
     * const tipoUsuario = await prisma.tipoUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tipoUsuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tipoUsuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoUsuario.
     * @param {tipoUsuarioUpsertArgs} args - Arguments to update or create a TipoUsuario.
     * @example
     * // Update or create a TipoUsuario
     * const tipoUsuario = await prisma.tipoUsuario.upsert({
     *   create: {
     *     // ... data to create a TipoUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoUsuario we want to update
     *   }
     * })
    **/
    upsert<T extends tipoUsuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tipoUsuarioUpsertArgs<ExtArgs>>
    ): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TipoUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoUsuarioCountArgs} args - Arguments to filter TipoUsuarios to count.
     * @example
     * // Count the number of TipoUsuarios
     * const count = await prisma.tipoUsuario.count({
     *   where: {
     *     // ... the filter for the TipoUsuarios we want to count
     *   }
     * })
    **/
    count<T extends tipoUsuarioCountArgs>(
      args?: Subset<T, tipoUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoUsuarioAggregateArgs>(args: Subset<T, TipoUsuarioAggregateArgs>): Prisma.PrismaPromise<GetTipoUsuarioAggregateType<T>>

    /**
     * Group by TipoUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: tipoUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoUsuario model
   */
  readonly fields: tipoUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoUsuarioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuario<T extends tipoUsuario$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, tipoUsuario$UsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tipoUsuario model
   */ 
  interface tipoUsuarioFieldRefs {
    readonly id: FieldRef<"tipoUsuario", 'Int'>
    readonly tipoUsuario: FieldRef<"tipoUsuario", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tipoUsuario findUnique
   */
  export type tipoUsuarioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which tipoUsuario to fetch.
     */
    where: tipoUsuarioWhereUniqueInput
  }


  /**
   * tipoUsuario findUniqueOrThrow
   */
  export type tipoUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which tipoUsuario to fetch.
     */
    where: tipoUsuarioWhereUniqueInput
  }


  /**
   * tipoUsuario findFirst
   */
  export type tipoUsuarioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which tipoUsuario to fetch.
     */
    where?: tipoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoUsuarios to fetch.
     */
    orderBy?: tipoUsuarioOrderByWithRelationInput | tipoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoUsuarios.
     */
    cursor?: tipoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoUsuarios.
     */
    distinct?: TipoUsuarioScalarFieldEnum | TipoUsuarioScalarFieldEnum[]
  }


  /**
   * tipoUsuario findFirstOrThrow
   */
  export type tipoUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which tipoUsuario to fetch.
     */
    where?: tipoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoUsuarios to fetch.
     */
    orderBy?: tipoUsuarioOrderByWithRelationInput | tipoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoUsuarios.
     */
    cursor?: tipoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoUsuarios.
     */
    distinct?: TipoUsuarioScalarFieldEnum | TipoUsuarioScalarFieldEnum[]
  }


  /**
   * tipoUsuario findMany
   */
  export type tipoUsuarioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which tipoUsuarios to fetch.
     */
    where?: tipoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoUsuarios to fetch.
     */
    orderBy?: tipoUsuarioOrderByWithRelationInput | tipoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoUsuarios.
     */
    cursor?: tipoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoUsuarios.
     */
    skip?: number
    distinct?: TipoUsuarioScalarFieldEnum | TipoUsuarioScalarFieldEnum[]
  }


  /**
   * tipoUsuario create
   */
  export type tipoUsuarioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoUsuario.
     */
    data: XOR<tipoUsuarioCreateInput, tipoUsuarioUncheckedCreateInput>
  }


  /**
   * tipoUsuario createMany
   */
  export type tipoUsuarioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoUsuarios.
     */
    data: tipoUsuarioCreateManyInput | tipoUsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tipoUsuario update
   */
  export type tipoUsuarioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoUsuario.
     */
    data: XOR<tipoUsuarioUpdateInput, tipoUsuarioUncheckedUpdateInput>
    /**
     * Choose, which tipoUsuario to update.
     */
    where: tipoUsuarioWhereUniqueInput
  }


  /**
   * tipoUsuario updateMany
   */
  export type tipoUsuarioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoUsuarios.
     */
    data: XOR<tipoUsuarioUpdateManyMutationInput, tipoUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which tipoUsuarios to update
     */
    where?: tipoUsuarioWhereInput
  }


  /**
   * tipoUsuario upsert
   */
  export type tipoUsuarioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoUsuario to update in case it exists.
     */
    where: tipoUsuarioWhereUniqueInput
    /**
     * In case the tipoUsuario found by the `where` argument doesn't exist, create a new tipoUsuario with this data.
     */
    create: XOR<tipoUsuarioCreateInput, tipoUsuarioUncheckedCreateInput>
    /**
     * In case the tipoUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoUsuarioUpdateInput, tipoUsuarioUncheckedUpdateInput>
  }


  /**
   * tipoUsuario delete
   */
  export type tipoUsuarioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
    /**
     * Filter which tipoUsuario to delete.
     */
    where: tipoUsuarioWhereUniqueInput
  }


  /**
   * tipoUsuario deleteMany
   */
  export type tipoUsuarioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoUsuarios to delete
     */
    where?: tipoUsuarioWhereInput
  }


  /**
   * tipoUsuario.Usuario
   */
  export type tipoUsuario$UsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * tipoUsuario without action
   */
  export type tipoUsuarioDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoUsuario
     */
    select?: tipoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoUsuarioInclude<ExtArgs> | null
  }



  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    rm: number | null
    codEscola: number | null
    codTipoUsuario: number | null
    codTurma: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    rm: number | null
    codEscola: number | null
    codTipoUsuario: number | null
    codTurma: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    email: string | null
    senha: string | null
    nome: string | null
    rm: number | null
    codEscola: number | null
    codTipoUsuario: number | null
    codTurma: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    email: string | null
    senha: string | null
    nome: string | null
    rm: number | null
    codEscola: number | null
    codTipoUsuario: number | null
    codTurma: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    email: number
    senha: number
    nome: number
    rm: number
    codEscola: number
    codTipoUsuario: number
    codTurma: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    rm?: true
    codEscola?: true
    codTipoUsuario?: true
    codTurma?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    rm?: true
    codEscola?: true
    codTipoUsuario?: true
    codTurma?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    nome?: true
    rm?: true
    codEscola?: true
    codTipoUsuario?: true
    codTurma?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    nome?: true
    rm?: true
    codEscola?: true
    codTipoUsuario?: true
    codTurma?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    nome?: true
    rm?: true
    codEscola?: true
    codTipoUsuario?: true
    codTurma?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    email: string
    senha: string
    nome: string
    rm: number | null
    codEscola: number | null
    codTipoUsuario: number
    codTurma: number | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    senha?: boolean
    nome?: boolean
    rm?: boolean
    codEscola?: boolean
    codTipoUsuario?: boolean
    codTurma?: boolean
    escolaRel?: boolean | Usuario$escolaRelArgs<ExtArgs>
    tipoUsuario?: boolean | tipoUsuarioDefaultArgs<ExtArgs>
    turma?: boolean | Usuario$turmaArgs<ExtArgs>
    Entrega?: boolean | Usuario$EntregaArgs<ExtArgs>
    SolicitacaoSuporte?: boolean | Usuario$SolicitacaoSuporteArgs<ExtArgs>
    Resposta?: boolean | Usuario$RespostaArgs<ExtArgs>
    Correcao?: boolean | Usuario$CorrecaoArgs<ExtArgs>
    Horas?: boolean | Usuario$HorasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    email?: boolean
    senha?: boolean
    nome?: boolean
    rm?: boolean
    codEscola?: boolean
    codTipoUsuario?: boolean
    codTurma?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    escolaRel?: boolean | Usuario$escolaRelArgs<ExtArgs>
    tipoUsuario?: boolean | tipoUsuarioDefaultArgs<ExtArgs>
    turma?: boolean | Usuario$turmaArgs<ExtArgs>
    Entrega?: boolean | Usuario$EntregaArgs<ExtArgs>
    SolicitacaoSuporte?: boolean | Usuario$SolicitacaoSuporteArgs<ExtArgs>
    Resposta?: boolean | Usuario$RespostaArgs<ExtArgs>
    Correcao?: boolean | Usuario$CorrecaoArgs<ExtArgs>
    Horas?: boolean | Usuario$HorasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UsuarioPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      escolaRel: Prisma.$EscolaPayload<ExtArgs> | null
      tipoUsuario: Prisma.$tipoUsuarioPayload<ExtArgs>
      turma: Prisma.$TurmaPayload<ExtArgs> | null
      Entrega: Prisma.$EntregaPayload<ExtArgs>[]
      SolicitacaoSuporte: Prisma.$SolicitacaoSuportePayload<ExtArgs>[]
      Resposta: Prisma.$RespostaPayload<ExtArgs>[]
      Correcao: Prisma.$CorrecaoPayload<ExtArgs>[]
      Horas: Prisma.$HorasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      email: string
      senha: string
      nome: string
      rm: number | null
      codEscola: number | null
      codTipoUsuario: number
      codTurma: number | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }


  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    escolaRel<T extends Usuario$escolaRelArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$escolaRelArgs<ExtArgs>>): Prisma__EscolaClient<$Result.GetResult<Prisma.$EscolaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    tipoUsuario<T extends tipoUsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoUsuarioDefaultArgs<ExtArgs>>): Prisma__tipoUsuarioClient<$Result.GetResult<Prisma.$tipoUsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    turma<T extends Usuario$turmaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$turmaArgs<ExtArgs>>): Prisma__TurmaClient<$Result.GetResult<Prisma.$TurmaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Entrega<T extends Usuario$EntregaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$EntregaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findMany'> | Null>;

    SolicitacaoSuporte<T extends Usuario$SolicitacaoSuporteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$SolicitacaoSuporteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'findMany'> | Null>;

    Resposta<T extends Usuario$RespostaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$RespostaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'findMany'> | Null>;

    Correcao<T extends Usuario$CorrecaoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$CorrecaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'findMany'> | Null>;

    Horas<T extends Usuario$HorasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$HorasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly rm: FieldRef<"Usuario", 'Int'>
    readonly codEscola: FieldRef<"Usuario", 'Int'>
    readonly codTipoUsuario: FieldRef<"Usuario", 'Int'>
    readonly codTurma: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario.escolaRel
   */
  export type Usuario$escolaRelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escola
     */
    select?: EscolaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EscolaInclude<ExtArgs> | null
    where?: EscolaWhereInput
  }


  /**
   * Usuario.turma
   */
  export type Usuario$turmaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turma
     */
    select?: TurmaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TurmaInclude<ExtArgs> | null
    where?: TurmaWhereInput
  }


  /**
   * Usuario.Entrega
   */
  export type Usuario$EntregaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    where?: EntregaWhereInput
    orderBy?: EntregaOrderByWithRelationInput | EntregaOrderByWithRelationInput[]
    cursor?: EntregaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntregaScalarFieldEnum | EntregaScalarFieldEnum[]
  }


  /**
   * Usuario.SolicitacaoSuporte
   */
  export type Usuario$SolicitacaoSuporteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    where?: SolicitacaoSuporteWhereInput
    orderBy?: SolicitacaoSuporteOrderByWithRelationInput | SolicitacaoSuporteOrderByWithRelationInput[]
    cursor?: SolicitacaoSuporteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SolicitacaoSuporteScalarFieldEnum | SolicitacaoSuporteScalarFieldEnum[]
  }


  /**
   * Usuario.Resposta
   */
  export type Usuario$RespostaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    where?: RespostaWhereInput
    orderBy?: RespostaOrderByWithRelationInput | RespostaOrderByWithRelationInput[]
    cursor?: RespostaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RespostaScalarFieldEnum | RespostaScalarFieldEnum[]
  }


  /**
   * Usuario.Correcao
   */
  export type Usuario$CorrecaoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    where?: CorrecaoWhereInput
    orderBy?: CorrecaoOrderByWithRelationInput | CorrecaoOrderByWithRelationInput[]
    cursor?: CorrecaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorrecaoScalarFieldEnum | CorrecaoScalarFieldEnum[]
  }


  /**
   * Usuario.Horas
   */
  export type Usuario$HorasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    where?: HorasWhereInput
    orderBy?: HorasOrderByWithRelationInput | HorasOrderByWithRelationInput[]
    cursor?: HorasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HorasScalarFieldEnum | HorasScalarFieldEnum[]
  }


  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
  }



  /**
   * Model Atividade
   */

  export type AggregateAtividade = {
    _count: AtividadeCountAggregateOutputType | null
    _avg: AtividadeAvgAggregateOutputType | null
    _sum: AtividadeSumAggregateOutputType | null
    _min: AtividadeMinAggregateOutputType | null
    _max: AtividadeMaxAggregateOutputType | null
  }

  export type AtividadeAvgAggregateOutputType = {
    id: number | null
    horasAtividade: number | null
    codTipoAtividade: number | null
  }

  export type AtividadeSumAggregateOutputType = {
    id: number | null
    horasAtividade: number | null
    codTipoAtividade: number | null
  }

  export type AtividadeMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    descricao: string | null
    anexos: string | null
    horasAtividade: number | null
    dataCriacao: Date | null
    prazoEntrega: Date | null
    codTipoAtividade: number | null
  }

  export type AtividadeMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    descricao: string | null
    anexos: string | null
    horasAtividade: number | null
    dataCriacao: Date | null
    prazoEntrega: Date | null
    codTipoAtividade: number | null
  }

  export type AtividadeCountAggregateOutputType = {
    id: number
    titulo: number
    descricao: number
    anexos: number
    horasAtividade: number
    dataCriacao: number
    prazoEntrega: number
    codTipoAtividade: number
    _all: number
  }


  export type AtividadeAvgAggregateInputType = {
    id?: true
    horasAtividade?: true
    codTipoAtividade?: true
  }

  export type AtividadeSumAggregateInputType = {
    id?: true
    horasAtividade?: true
    codTipoAtividade?: true
  }

  export type AtividadeMinAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    anexos?: true
    horasAtividade?: true
    dataCriacao?: true
    prazoEntrega?: true
    codTipoAtividade?: true
  }

  export type AtividadeMaxAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    anexos?: true
    horasAtividade?: true
    dataCriacao?: true
    prazoEntrega?: true
    codTipoAtividade?: true
  }

  export type AtividadeCountAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    anexos?: true
    horasAtividade?: true
    dataCriacao?: true
    prazoEntrega?: true
    codTipoAtividade?: true
    _all?: true
  }

  export type AtividadeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Atividade to aggregate.
     */
    where?: AtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atividades to fetch.
     */
    orderBy?: AtividadeOrderByWithRelationInput | AtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Atividades
    **/
    _count?: true | AtividadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AtividadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AtividadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AtividadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AtividadeMaxAggregateInputType
  }

  export type GetAtividadeAggregateType<T extends AtividadeAggregateArgs> = {
        [P in keyof T & keyof AggregateAtividade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtividade[P]>
      : GetScalarType<T[P], AggregateAtividade[P]>
  }




  export type AtividadeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AtividadeWhereInput
    orderBy?: AtividadeOrderByWithAggregationInput | AtividadeOrderByWithAggregationInput[]
    by: AtividadeScalarFieldEnum[] | AtividadeScalarFieldEnum
    having?: AtividadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AtividadeCountAggregateInputType | true
    _avg?: AtividadeAvgAggregateInputType
    _sum?: AtividadeSumAggregateInputType
    _min?: AtividadeMinAggregateInputType
    _max?: AtividadeMaxAggregateInputType
  }

  export type AtividadeGroupByOutputType = {
    id: number
    titulo: string
    descricao: string
    anexos: string | null
    horasAtividade: number
    dataCriacao: Date
    prazoEntrega: Date
    codTipoAtividade: number
    _count: AtividadeCountAggregateOutputType | null
    _avg: AtividadeAvgAggregateOutputType | null
    _sum: AtividadeSumAggregateOutputType | null
    _min: AtividadeMinAggregateOutputType | null
    _max: AtividadeMaxAggregateOutputType | null
  }

  type GetAtividadeGroupByPayload<T extends AtividadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AtividadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AtividadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AtividadeGroupByOutputType[P]>
            : GetScalarType<T[P], AtividadeGroupByOutputType[P]>
        }
      >
    >


  export type AtividadeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    anexos?: boolean
    horasAtividade?: boolean
    dataCriacao?: boolean
    prazoEntrega?: boolean
    codTipoAtividade?: boolean
    tipoAtividade?: boolean | tipoAtividadeDefaultArgs<ExtArgs>
    entrega?: boolean | Atividade$entregaArgs<ExtArgs>
    _count?: boolean | AtividadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["atividade"]>

  export type AtividadeSelectScalar = {
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    anexos?: boolean
    horasAtividade?: boolean
    dataCriacao?: boolean
    prazoEntrega?: boolean
    codTipoAtividade?: boolean
  }

  export type AtividadeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    tipoAtividade?: boolean | tipoAtividadeDefaultArgs<ExtArgs>
    entrega?: boolean | Atividade$entregaArgs<ExtArgs>
    _count?: boolean | AtividadeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AtividadePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Atividade"
    objects: {
      tipoAtividade: Prisma.$tipoAtividadePayload<ExtArgs>
      entrega: Prisma.$EntregaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      titulo: string
      descricao: string
      anexos: string | null
      horasAtividade: number
      dataCriacao: Date
      prazoEntrega: Date
      codTipoAtividade: number
    }, ExtArgs["result"]["atividade"]>
    composites: {}
  }


  type AtividadeGetPayload<S extends boolean | null | undefined | AtividadeDefaultArgs> = $Result.GetResult<Prisma.$AtividadePayload, S>

  type AtividadeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AtividadeFindManyArgs, 'select' | 'include'> & {
      select?: AtividadeCountAggregateInputType | true
    }

  export interface AtividadeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Atividade'], meta: { name: 'Atividade' } }
    /**
     * Find zero or one Atividade that matches the filter.
     * @param {AtividadeFindUniqueArgs} args - Arguments to find a Atividade
     * @example
     * // Get one Atividade
     * const atividade = await prisma.atividade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AtividadeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AtividadeFindUniqueArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Atividade that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AtividadeFindUniqueOrThrowArgs} args - Arguments to find a Atividade
     * @example
     * // Get one Atividade
     * const atividade = await prisma.atividade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AtividadeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AtividadeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Atividade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadeFindFirstArgs} args - Arguments to find a Atividade
     * @example
     * // Get one Atividade
     * const atividade = await prisma.atividade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AtividadeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AtividadeFindFirstArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Atividade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadeFindFirstOrThrowArgs} args - Arguments to find a Atividade
     * @example
     * // Get one Atividade
     * const atividade = await prisma.atividade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AtividadeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AtividadeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Atividades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Atividades
     * const atividades = await prisma.atividade.findMany()
     * 
     * // Get first 10 Atividades
     * const atividades = await prisma.atividade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const atividadeWithIdOnly = await prisma.atividade.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AtividadeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AtividadeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Atividade.
     * @param {AtividadeCreateArgs} args - Arguments to create a Atividade.
     * @example
     * // Create one Atividade
     * const Atividade = await prisma.atividade.create({
     *   data: {
     *     // ... data to create a Atividade
     *   }
     * })
     * 
    **/
    create<T extends AtividadeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AtividadeCreateArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Atividades.
     *     @param {AtividadeCreateManyArgs} args - Arguments to create many Atividades.
     *     @example
     *     // Create many Atividades
     *     const atividade = await prisma.atividade.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AtividadeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AtividadeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Atividade.
     * @param {AtividadeDeleteArgs} args - Arguments to delete one Atividade.
     * @example
     * // Delete one Atividade
     * const Atividade = await prisma.atividade.delete({
     *   where: {
     *     // ... filter to delete one Atividade
     *   }
     * })
     * 
    **/
    delete<T extends AtividadeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AtividadeDeleteArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Atividade.
     * @param {AtividadeUpdateArgs} args - Arguments to update one Atividade.
     * @example
     * // Update one Atividade
     * const atividade = await prisma.atividade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AtividadeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AtividadeUpdateArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Atividades.
     * @param {AtividadeDeleteManyArgs} args - Arguments to filter Atividades to delete.
     * @example
     * // Delete a few Atividades
     * const { count } = await prisma.atividade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AtividadeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AtividadeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Atividades
     * const atividade = await prisma.atividade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AtividadeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AtividadeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Atividade.
     * @param {AtividadeUpsertArgs} args - Arguments to update or create a Atividade.
     * @example
     * // Update or create a Atividade
     * const atividade = await prisma.atividade.upsert({
     *   create: {
     *     // ... data to create a Atividade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Atividade we want to update
     *   }
     * })
    **/
    upsert<T extends AtividadeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AtividadeUpsertArgs<ExtArgs>>
    ): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Atividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadeCountArgs} args - Arguments to filter Atividades to count.
     * @example
     * // Count the number of Atividades
     * const count = await prisma.atividade.count({
     *   where: {
     *     // ... the filter for the Atividades we want to count
     *   }
     * })
    **/
    count<T extends AtividadeCountArgs>(
      args?: Subset<T, AtividadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AtividadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Atividade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AtividadeAggregateArgs>(args: Subset<T, AtividadeAggregateArgs>): Prisma.PrismaPromise<GetAtividadeAggregateType<T>>

    /**
     * Group by Atividade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AtividadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AtividadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AtividadeGroupByArgs['orderBy'] }
        : { orderBy?: AtividadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AtividadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtividadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Atividade model
   */
  readonly fields: AtividadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Atividade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AtividadeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tipoAtividade<T extends tipoAtividadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoAtividadeDefaultArgs<ExtArgs>>): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entrega<T extends Atividade$entregaArgs<ExtArgs> = {}>(args?: Subset<T, Atividade$entregaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Atividade model
   */ 
  interface AtividadeFieldRefs {
    readonly id: FieldRef<"Atividade", 'Int'>
    readonly titulo: FieldRef<"Atividade", 'String'>
    readonly descricao: FieldRef<"Atividade", 'String'>
    readonly anexos: FieldRef<"Atividade", 'String'>
    readonly horasAtividade: FieldRef<"Atividade", 'Int'>
    readonly dataCriacao: FieldRef<"Atividade", 'DateTime'>
    readonly prazoEntrega: FieldRef<"Atividade", 'DateTime'>
    readonly codTipoAtividade: FieldRef<"Atividade", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Atividade findUnique
   */
  export type AtividadeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * Filter, which Atividade to fetch.
     */
    where: AtividadeWhereUniqueInput
  }


  /**
   * Atividade findUniqueOrThrow
   */
  export type AtividadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * Filter, which Atividade to fetch.
     */
    where: AtividadeWhereUniqueInput
  }


  /**
   * Atividade findFirst
   */
  export type AtividadeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * Filter, which Atividade to fetch.
     */
    where?: AtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atividades to fetch.
     */
    orderBy?: AtividadeOrderByWithRelationInput | AtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Atividades.
     */
    cursor?: AtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Atividades.
     */
    distinct?: AtividadeScalarFieldEnum | AtividadeScalarFieldEnum[]
  }


  /**
   * Atividade findFirstOrThrow
   */
  export type AtividadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * Filter, which Atividade to fetch.
     */
    where?: AtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atividades to fetch.
     */
    orderBy?: AtividadeOrderByWithRelationInput | AtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Atividades.
     */
    cursor?: AtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Atividades.
     */
    distinct?: AtividadeScalarFieldEnum | AtividadeScalarFieldEnum[]
  }


  /**
   * Atividade findMany
   */
  export type AtividadeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * Filter, which Atividades to fetch.
     */
    where?: AtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Atividades to fetch.
     */
    orderBy?: AtividadeOrderByWithRelationInput | AtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Atividades.
     */
    cursor?: AtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Atividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Atividades.
     */
    skip?: number
    distinct?: AtividadeScalarFieldEnum | AtividadeScalarFieldEnum[]
  }


  /**
   * Atividade create
   */
  export type AtividadeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * The data needed to create a Atividade.
     */
    data: XOR<AtividadeCreateInput, AtividadeUncheckedCreateInput>
  }


  /**
   * Atividade createMany
   */
  export type AtividadeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Atividades.
     */
    data: AtividadeCreateManyInput | AtividadeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Atividade update
   */
  export type AtividadeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * The data needed to update a Atividade.
     */
    data: XOR<AtividadeUpdateInput, AtividadeUncheckedUpdateInput>
    /**
     * Choose, which Atividade to update.
     */
    where: AtividadeWhereUniqueInput
  }


  /**
   * Atividade updateMany
   */
  export type AtividadeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Atividades.
     */
    data: XOR<AtividadeUpdateManyMutationInput, AtividadeUncheckedUpdateManyInput>
    /**
     * Filter which Atividades to update
     */
    where?: AtividadeWhereInput
  }


  /**
   * Atividade upsert
   */
  export type AtividadeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * The filter to search for the Atividade to update in case it exists.
     */
    where: AtividadeWhereUniqueInput
    /**
     * In case the Atividade found by the `where` argument doesn't exist, create a new Atividade with this data.
     */
    create: XOR<AtividadeCreateInput, AtividadeUncheckedCreateInput>
    /**
     * In case the Atividade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AtividadeUpdateInput, AtividadeUncheckedUpdateInput>
  }


  /**
   * Atividade delete
   */
  export type AtividadeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    /**
     * Filter which Atividade to delete.
     */
    where: AtividadeWhereUniqueInput
  }


  /**
   * Atividade deleteMany
   */
  export type AtividadeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Atividades to delete
     */
    where?: AtividadeWhereInput
  }


  /**
   * Atividade.entrega
   */
  export type Atividade$entregaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    where?: EntregaWhereInput
    orderBy?: EntregaOrderByWithRelationInput | EntregaOrderByWithRelationInput[]
    cursor?: EntregaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntregaScalarFieldEnum | EntregaScalarFieldEnum[]
  }


  /**
   * Atividade without action
   */
  export type AtividadeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
  }



  /**
   * Model tipoAtividade
   */

  export type AggregateTipoAtividade = {
    _count: TipoAtividadeCountAggregateOutputType | null
    _avg: TipoAtividadeAvgAggregateOutputType | null
    _sum: TipoAtividadeSumAggregateOutputType | null
    _min: TipoAtividadeMinAggregateOutputType | null
    _max: TipoAtividadeMaxAggregateOutputType | null
  }

  export type TipoAtividadeAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoAtividadeSumAggregateOutputType = {
    id: number | null
  }

  export type TipoAtividadeMinAggregateOutputType = {
    id: number | null
    tipoAtividade: string | null
  }

  export type TipoAtividadeMaxAggregateOutputType = {
    id: number | null
    tipoAtividade: string | null
  }

  export type TipoAtividadeCountAggregateOutputType = {
    id: number
    tipoAtividade: number
    _all: number
  }


  export type TipoAtividadeAvgAggregateInputType = {
    id?: true
  }

  export type TipoAtividadeSumAggregateInputType = {
    id?: true
  }

  export type TipoAtividadeMinAggregateInputType = {
    id?: true
    tipoAtividade?: true
  }

  export type TipoAtividadeMaxAggregateInputType = {
    id?: true
    tipoAtividade?: true
  }

  export type TipoAtividadeCountAggregateInputType = {
    id?: true
    tipoAtividade?: true
    _all?: true
  }

  export type TipoAtividadeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoAtividade to aggregate.
     */
    where?: tipoAtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoAtividades to fetch.
     */
    orderBy?: tipoAtividadeOrderByWithRelationInput | tipoAtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoAtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoAtividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoAtividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoAtividades
    **/
    _count?: true | TipoAtividadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoAtividadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoAtividadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoAtividadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoAtividadeMaxAggregateInputType
  }

  export type GetTipoAtividadeAggregateType<T extends TipoAtividadeAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoAtividade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoAtividade[P]>
      : GetScalarType<T[P], AggregateTipoAtividade[P]>
  }




  export type tipoAtividadeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: tipoAtividadeWhereInput
    orderBy?: tipoAtividadeOrderByWithAggregationInput | tipoAtividadeOrderByWithAggregationInput[]
    by: TipoAtividadeScalarFieldEnum[] | TipoAtividadeScalarFieldEnum
    having?: tipoAtividadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoAtividadeCountAggregateInputType | true
    _avg?: TipoAtividadeAvgAggregateInputType
    _sum?: TipoAtividadeSumAggregateInputType
    _min?: TipoAtividadeMinAggregateInputType
    _max?: TipoAtividadeMaxAggregateInputType
  }

  export type TipoAtividadeGroupByOutputType = {
    id: number
    tipoAtividade: string
    _count: TipoAtividadeCountAggregateOutputType | null
    _avg: TipoAtividadeAvgAggregateOutputType | null
    _sum: TipoAtividadeSumAggregateOutputType | null
    _min: TipoAtividadeMinAggregateOutputType | null
    _max: TipoAtividadeMaxAggregateOutputType | null
  }

  type GetTipoAtividadeGroupByPayload<T extends tipoAtividadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoAtividadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoAtividadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoAtividadeGroupByOutputType[P]>
            : GetScalarType<T[P], TipoAtividadeGroupByOutputType[P]>
        }
      >
    >


  export type tipoAtividadeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoAtividade?: boolean
    Atividade?: boolean | tipoAtividade$AtividadeArgs<ExtArgs>
    _count?: boolean | TipoAtividadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoAtividade"]>

  export type tipoAtividadeSelectScalar = {
    id?: boolean
    tipoAtividade?: boolean
  }

  export type tipoAtividadeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Atividade?: boolean | tipoAtividade$AtividadeArgs<ExtArgs>
    _count?: boolean | TipoAtividadeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $tipoAtividadePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "tipoAtividade"
    objects: {
      Atividade: Prisma.$AtividadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      tipoAtividade: string
    }, ExtArgs["result"]["tipoAtividade"]>
    composites: {}
  }


  type tipoAtividadeGetPayload<S extends boolean | null | undefined | tipoAtividadeDefaultArgs> = $Result.GetResult<Prisma.$tipoAtividadePayload, S>

  type tipoAtividadeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<tipoAtividadeFindManyArgs, 'select' | 'include'> & {
      select?: TipoAtividadeCountAggregateInputType | true
    }

  export interface tipoAtividadeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoAtividade'], meta: { name: 'tipoAtividade' } }
    /**
     * Find zero or one TipoAtividade that matches the filter.
     * @param {tipoAtividadeFindUniqueArgs} args - Arguments to find a TipoAtividade
     * @example
     * // Get one TipoAtividade
     * const tipoAtividade = await prisma.tipoAtividade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tipoAtividadeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, tipoAtividadeFindUniqueArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TipoAtividade that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tipoAtividadeFindUniqueOrThrowArgs} args - Arguments to find a TipoAtividade
     * @example
     * // Get one TipoAtividade
     * const tipoAtividade = await prisma.tipoAtividade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tipoAtividadeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoAtividadeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TipoAtividade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoAtividadeFindFirstArgs} args - Arguments to find a TipoAtividade
     * @example
     * // Get one TipoAtividade
     * const tipoAtividade = await prisma.tipoAtividade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tipoAtividadeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoAtividadeFindFirstArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TipoAtividade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoAtividadeFindFirstOrThrowArgs} args - Arguments to find a TipoAtividade
     * @example
     * // Get one TipoAtividade
     * const tipoAtividade = await prisma.tipoAtividade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tipoAtividadeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoAtividadeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TipoAtividades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoAtividadeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoAtividades
     * const tipoAtividades = await prisma.tipoAtividade.findMany()
     * 
     * // Get first 10 TipoAtividades
     * const tipoAtividades = await prisma.tipoAtividade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoAtividadeWithIdOnly = await prisma.tipoAtividade.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tipoAtividadeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoAtividadeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TipoAtividade.
     * @param {tipoAtividadeCreateArgs} args - Arguments to create a TipoAtividade.
     * @example
     * // Create one TipoAtividade
     * const TipoAtividade = await prisma.tipoAtividade.create({
     *   data: {
     *     // ... data to create a TipoAtividade
     *   }
     * })
     * 
    **/
    create<T extends tipoAtividadeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, tipoAtividadeCreateArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TipoAtividades.
     *     @param {tipoAtividadeCreateManyArgs} args - Arguments to create many TipoAtividades.
     *     @example
     *     // Create many TipoAtividades
     *     const tipoAtividade = await prisma.tipoAtividade.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tipoAtividadeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoAtividadeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TipoAtividade.
     * @param {tipoAtividadeDeleteArgs} args - Arguments to delete one TipoAtividade.
     * @example
     * // Delete one TipoAtividade
     * const TipoAtividade = await prisma.tipoAtividade.delete({
     *   where: {
     *     // ... filter to delete one TipoAtividade
     *   }
     * })
     * 
    **/
    delete<T extends tipoAtividadeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, tipoAtividadeDeleteArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TipoAtividade.
     * @param {tipoAtividadeUpdateArgs} args - Arguments to update one TipoAtividade.
     * @example
     * // Update one TipoAtividade
     * const tipoAtividade = await prisma.tipoAtividade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tipoAtividadeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, tipoAtividadeUpdateArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TipoAtividades.
     * @param {tipoAtividadeDeleteManyArgs} args - Arguments to filter TipoAtividades to delete.
     * @example
     * // Delete a few TipoAtividades
     * const { count } = await prisma.tipoAtividade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tipoAtividadeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, tipoAtividadeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAtividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoAtividadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoAtividades
     * const tipoAtividade = await prisma.tipoAtividade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tipoAtividadeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, tipoAtividadeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoAtividade.
     * @param {tipoAtividadeUpsertArgs} args - Arguments to update or create a TipoAtividade.
     * @example
     * // Update or create a TipoAtividade
     * const tipoAtividade = await prisma.tipoAtividade.upsert({
     *   create: {
     *     // ... data to create a TipoAtividade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoAtividade we want to update
     *   }
     * })
    **/
    upsert<T extends tipoAtividadeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, tipoAtividadeUpsertArgs<ExtArgs>>
    ): Prisma__tipoAtividadeClient<$Result.GetResult<Prisma.$tipoAtividadePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TipoAtividades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoAtividadeCountArgs} args - Arguments to filter TipoAtividades to count.
     * @example
     * // Count the number of TipoAtividades
     * const count = await prisma.tipoAtividade.count({
     *   where: {
     *     // ... the filter for the TipoAtividades we want to count
     *   }
     * })
    **/
    count<T extends tipoAtividadeCountArgs>(
      args?: Subset<T, tipoAtividadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoAtividadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoAtividade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAtividadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoAtividadeAggregateArgs>(args: Subset<T, TipoAtividadeAggregateArgs>): Prisma.PrismaPromise<GetTipoAtividadeAggregateType<T>>

    /**
     * Group by TipoAtividade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoAtividadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoAtividadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoAtividadeGroupByArgs['orderBy'] }
        : { orderBy?: tipoAtividadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoAtividadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoAtividadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoAtividade model
   */
  readonly fields: tipoAtividadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoAtividade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoAtividadeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Atividade<T extends tipoAtividade$AtividadeArgs<ExtArgs> = {}>(args?: Subset<T, tipoAtividade$AtividadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the tipoAtividade model
   */ 
  interface tipoAtividadeFieldRefs {
    readonly id: FieldRef<"tipoAtividade", 'Int'>
    readonly tipoAtividade: FieldRef<"tipoAtividade", 'String'>
  }
    

  // Custom InputTypes

  /**
   * tipoAtividade findUnique
   */
  export type tipoAtividadeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoAtividade to fetch.
     */
    where: tipoAtividadeWhereUniqueInput
  }


  /**
   * tipoAtividade findUniqueOrThrow
   */
  export type tipoAtividadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoAtividade to fetch.
     */
    where: tipoAtividadeWhereUniqueInput
  }


  /**
   * tipoAtividade findFirst
   */
  export type tipoAtividadeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoAtividade to fetch.
     */
    where?: tipoAtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoAtividades to fetch.
     */
    orderBy?: tipoAtividadeOrderByWithRelationInput | tipoAtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoAtividades.
     */
    cursor?: tipoAtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoAtividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoAtividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoAtividades.
     */
    distinct?: TipoAtividadeScalarFieldEnum | TipoAtividadeScalarFieldEnum[]
  }


  /**
   * tipoAtividade findFirstOrThrow
   */
  export type tipoAtividadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoAtividade to fetch.
     */
    where?: tipoAtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoAtividades to fetch.
     */
    orderBy?: tipoAtividadeOrderByWithRelationInput | tipoAtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoAtividades.
     */
    cursor?: tipoAtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoAtividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoAtividades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoAtividades.
     */
    distinct?: TipoAtividadeScalarFieldEnum | TipoAtividadeScalarFieldEnum[]
  }


  /**
   * tipoAtividade findMany
   */
  export type tipoAtividadeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoAtividades to fetch.
     */
    where?: tipoAtividadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoAtividades to fetch.
     */
    orderBy?: tipoAtividadeOrderByWithRelationInput | tipoAtividadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoAtividades.
     */
    cursor?: tipoAtividadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoAtividades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoAtividades.
     */
    skip?: number
    distinct?: TipoAtividadeScalarFieldEnum | TipoAtividadeScalarFieldEnum[]
  }


  /**
   * tipoAtividade create
   */
  export type tipoAtividadeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoAtividade.
     */
    data: XOR<tipoAtividadeCreateInput, tipoAtividadeUncheckedCreateInput>
  }


  /**
   * tipoAtividade createMany
   */
  export type tipoAtividadeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoAtividades.
     */
    data: tipoAtividadeCreateManyInput | tipoAtividadeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * tipoAtividade update
   */
  export type tipoAtividadeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoAtividade.
     */
    data: XOR<tipoAtividadeUpdateInput, tipoAtividadeUncheckedUpdateInput>
    /**
     * Choose, which tipoAtividade to update.
     */
    where: tipoAtividadeWhereUniqueInput
  }


  /**
   * tipoAtividade updateMany
   */
  export type tipoAtividadeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoAtividades.
     */
    data: XOR<tipoAtividadeUpdateManyMutationInput, tipoAtividadeUncheckedUpdateManyInput>
    /**
     * Filter which tipoAtividades to update
     */
    where?: tipoAtividadeWhereInput
  }


  /**
   * tipoAtividade upsert
   */
  export type tipoAtividadeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoAtividade to update in case it exists.
     */
    where: tipoAtividadeWhereUniqueInput
    /**
     * In case the tipoAtividade found by the `where` argument doesn't exist, create a new tipoAtividade with this data.
     */
    create: XOR<tipoAtividadeCreateInput, tipoAtividadeUncheckedCreateInput>
    /**
     * In case the tipoAtividade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoAtividadeUpdateInput, tipoAtividadeUncheckedUpdateInput>
  }


  /**
   * tipoAtividade delete
   */
  export type tipoAtividadeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
    /**
     * Filter which tipoAtividade to delete.
     */
    where: tipoAtividadeWhereUniqueInput
  }


  /**
   * tipoAtividade deleteMany
   */
  export type tipoAtividadeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoAtividades to delete
     */
    where?: tipoAtividadeWhereInput
  }


  /**
   * tipoAtividade.Atividade
   */
  export type tipoAtividade$AtividadeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Atividade
     */
    select?: AtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AtividadeInclude<ExtArgs> | null
    where?: AtividadeWhereInput
    orderBy?: AtividadeOrderByWithRelationInput | AtividadeOrderByWithRelationInput[]
    cursor?: AtividadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AtividadeScalarFieldEnum | AtividadeScalarFieldEnum[]
  }


  /**
   * tipoAtividade without action
   */
  export type tipoAtividadeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoAtividade
     */
    select?: tipoAtividadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipoAtividadeInclude<ExtArgs> | null
  }



  /**
   * Model Entrega
   */

  export type AggregateEntrega = {
    _count: EntregaCountAggregateOutputType | null
    _avg: EntregaAvgAggregateOutputType | null
    _sum: EntregaSumAggregateOutputType | null
    _min: EntregaMinAggregateOutputType | null
    _max: EntregaMaxAggregateOutputType | null
  }

  export type EntregaAvgAggregateOutputType = {
    id: number | null
    codAluno: number | null
    codAtividade: number | null
  }

  export type EntregaSumAggregateOutputType = {
    id: number | null
    codAluno: number | null
    codAtividade: number | null
  }

  export type EntregaMinAggregateOutputType = {
    id: number | null
    dataEntrega: Date | null
    conteudo: string | null
    entregue: boolean | null
    codAluno: number | null
    codAtividade: number | null
  }

  export type EntregaMaxAggregateOutputType = {
    id: number | null
    dataEntrega: Date | null
    conteudo: string | null
    entregue: boolean | null
    codAluno: number | null
    codAtividade: number | null
  }

  export type EntregaCountAggregateOutputType = {
    id: number
    dataEntrega: number
    conteudo: number
    entregue: number
    codAluno: number
    codAtividade: number
    _all: number
  }


  export type EntregaAvgAggregateInputType = {
    id?: true
    codAluno?: true
    codAtividade?: true
  }

  export type EntregaSumAggregateInputType = {
    id?: true
    codAluno?: true
    codAtividade?: true
  }

  export type EntregaMinAggregateInputType = {
    id?: true
    dataEntrega?: true
    conteudo?: true
    entregue?: true
    codAluno?: true
    codAtividade?: true
  }

  export type EntregaMaxAggregateInputType = {
    id?: true
    dataEntrega?: true
    conteudo?: true
    entregue?: true
    codAluno?: true
    codAtividade?: true
  }

  export type EntregaCountAggregateInputType = {
    id?: true
    dataEntrega?: true
    conteudo?: true
    entregue?: true
    codAluno?: true
    codAtividade?: true
    _all?: true
  }

  export type EntregaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entrega to aggregate.
     */
    where?: EntregaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entregas to fetch.
     */
    orderBy?: EntregaOrderByWithRelationInput | EntregaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntregaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entregas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entregas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entregas
    **/
    _count?: true | EntregaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntregaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntregaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntregaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntregaMaxAggregateInputType
  }

  export type GetEntregaAggregateType<T extends EntregaAggregateArgs> = {
        [P in keyof T & keyof AggregateEntrega]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntrega[P]>
      : GetScalarType<T[P], AggregateEntrega[P]>
  }




  export type EntregaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EntregaWhereInput
    orderBy?: EntregaOrderByWithAggregationInput | EntregaOrderByWithAggregationInput[]
    by: EntregaScalarFieldEnum[] | EntregaScalarFieldEnum
    having?: EntregaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntregaCountAggregateInputType | true
    _avg?: EntregaAvgAggregateInputType
    _sum?: EntregaSumAggregateInputType
    _min?: EntregaMinAggregateInputType
    _max?: EntregaMaxAggregateInputType
  }

  export type EntregaGroupByOutputType = {
    id: number
    dataEntrega: Date | null
    conteudo: string | null
    entregue: boolean
    codAluno: number
    codAtividade: number
    _count: EntregaCountAggregateOutputType | null
    _avg: EntregaAvgAggregateOutputType | null
    _sum: EntregaSumAggregateOutputType | null
    _min: EntregaMinAggregateOutputType | null
    _max: EntregaMaxAggregateOutputType | null
  }

  type GetEntregaGroupByPayload<T extends EntregaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntregaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntregaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntregaGroupByOutputType[P]>
            : GetScalarType<T[P], EntregaGroupByOutputType[P]>
        }
      >
    >


  export type EntregaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dataEntrega?: boolean
    conteudo?: boolean
    entregue?: boolean
    codAluno?: boolean
    codAtividade?: boolean
    aluno?: boolean | UsuarioDefaultArgs<ExtArgs>
    atividade?: boolean | AtividadeDefaultArgs<ExtArgs>
    Correcao?: boolean | Entrega$CorrecaoArgs<ExtArgs>
  }, ExtArgs["result"]["entrega"]>

  export type EntregaSelectScalar = {
    id?: boolean
    dataEntrega?: boolean
    conteudo?: boolean
    entregue?: boolean
    codAluno?: boolean
    codAtividade?: boolean
  }

  export type EntregaInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    aluno?: boolean | UsuarioDefaultArgs<ExtArgs>
    atividade?: boolean | AtividadeDefaultArgs<ExtArgs>
    Correcao?: boolean | Entrega$CorrecaoArgs<ExtArgs>
  }


  export type $EntregaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Entrega"
    objects: {
      aluno: Prisma.$UsuarioPayload<ExtArgs>
      atividade: Prisma.$AtividadePayload<ExtArgs>
      Correcao: Prisma.$CorrecaoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      dataEntrega: Date | null
      conteudo: string | null
      entregue: boolean
      codAluno: number
      codAtividade: number
    }, ExtArgs["result"]["entrega"]>
    composites: {}
  }


  type EntregaGetPayload<S extends boolean | null | undefined | EntregaDefaultArgs> = $Result.GetResult<Prisma.$EntregaPayload, S>

  type EntregaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EntregaFindManyArgs, 'select' | 'include'> & {
      select?: EntregaCountAggregateInputType | true
    }

  export interface EntregaDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entrega'], meta: { name: 'Entrega' } }
    /**
     * Find zero or one Entrega that matches the filter.
     * @param {EntregaFindUniqueArgs} args - Arguments to find a Entrega
     * @example
     * // Get one Entrega
     * const entrega = await prisma.entrega.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EntregaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EntregaFindUniqueArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Entrega that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EntregaFindUniqueOrThrowArgs} args - Arguments to find a Entrega
     * @example
     * // Get one Entrega
     * const entrega = await prisma.entrega.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EntregaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntregaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Entrega that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregaFindFirstArgs} args - Arguments to find a Entrega
     * @example
     * // Get one Entrega
     * const entrega = await prisma.entrega.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EntregaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EntregaFindFirstArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Entrega that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregaFindFirstOrThrowArgs} args - Arguments to find a Entrega
     * @example
     * // Get one Entrega
     * const entrega = await prisma.entrega.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EntregaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EntregaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Entregas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entregas
     * const entregas = await prisma.entrega.findMany()
     * 
     * // Get first 10 Entregas
     * const entregas = await prisma.entrega.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entregaWithIdOnly = await prisma.entrega.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EntregaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntregaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Entrega.
     * @param {EntregaCreateArgs} args - Arguments to create a Entrega.
     * @example
     * // Create one Entrega
     * const Entrega = await prisma.entrega.create({
     *   data: {
     *     // ... data to create a Entrega
     *   }
     * })
     * 
    **/
    create<T extends EntregaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EntregaCreateArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Entregas.
     *     @param {EntregaCreateManyArgs} args - Arguments to create many Entregas.
     *     @example
     *     // Create many Entregas
     *     const entrega = await prisma.entrega.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EntregaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntregaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entrega.
     * @param {EntregaDeleteArgs} args - Arguments to delete one Entrega.
     * @example
     * // Delete one Entrega
     * const Entrega = await prisma.entrega.delete({
     *   where: {
     *     // ... filter to delete one Entrega
     *   }
     * })
     * 
    **/
    delete<T extends EntregaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EntregaDeleteArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Entrega.
     * @param {EntregaUpdateArgs} args - Arguments to update one Entrega.
     * @example
     * // Update one Entrega
     * const entrega = await prisma.entrega.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EntregaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EntregaUpdateArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Entregas.
     * @param {EntregaDeleteManyArgs} args - Arguments to filter Entregas to delete.
     * @example
     * // Delete a few Entregas
     * const { count } = await prisma.entrega.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EntregaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EntregaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entregas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entregas
     * const entrega = await prisma.entrega.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EntregaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EntregaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entrega.
     * @param {EntregaUpsertArgs} args - Arguments to update or create a Entrega.
     * @example
     * // Update or create a Entrega
     * const entrega = await prisma.entrega.upsert({
     *   create: {
     *     // ... data to create a Entrega
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entrega we want to update
     *   }
     * })
    **/
    upsert<T extends EntregaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EntregaUpsertArgs<ExtArgs>>
    ): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Entregas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregaCountArgs} args - Arguments to filter Entregas to count.
     * @example
     * // Count the number of Entregas
     * const count = await prisma.entrega.count({
     *   where: {
     *     // ... the filter for the Entregas we want to count
     *   }
     * })
    **/
    count<T extends EntregaCountArgs>(
      args?: Subset<T, EntregaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntregaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entrega.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntregaAggregateArgs>(args: Subset<T, EntregaAggregateArgs>): Prisma.PrismaPromise<GetEntregaAggregateType<T>>

    /**
     * Group by Entrega.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntregaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntregaGroupByArgs['orderBy'] }
        : { orderBy?: EntregaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntregaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntregaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entrega model
   */
  readonly fields: EntregaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entrega.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntregaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    aluno<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    atividade<T extends AtividadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AtividadeDefaultArgs<ExtArgs>>): Prisma__AtividadeClient<$Result.GetResult<Prisma.$AtividadePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Correcao<T extends Entrega$CorrecaoArgs<ExtArgs> = {}>(args?: Subset<T, Entrega$CorrecaoArgs<ExtArgs>>): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Entrega model
   */ 
  interface EntregaFieldRefs {
    readonly id: FieldRef<"Entrega", 'Int'>
    readonly dataEntrega: FieldRef<"Entrega", 'DateTime'>
    readonly conteudo: FieldRef<"Entrega", 'String'>
    readonly entregue: FieldRef<"Entrega", 'Boolean'>
    readonly codAluno: FieldRef<"Entrega", 'Int'>
    readonly codAtividade: FieldRef<"Entrega", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Entrega findUnique
   */
  export type EntregaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * Filter, which Entrega to fetch.
     */
    where: EntregaWhereUniqueInput
  }


  /**
   * Entrega findUniqueOrThrow
   */
  export type EntregaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * Filter, which Entrega to fetch.
     */
    where: EntregaWhereUniqueInput
  }


  /**
   * Entrega findFirst
   */
  export type EntregaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * Filter, which Entrega to fetch.
     */
    where?: EntregaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entregas to fetch.
     */
    orderBy?: EntregaOrderByWithRelationInput | EntregaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entregas.
     */
    cursor?: EntregaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entregas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entregas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entregas.
     */
    distinct?: EntregaScalarFieldEnum | EntregaScalarFieldEnum[]
  }


  /**
   * Entrega findFirstOrThrow
   */
  export type EntregaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * Filter, which Entrega to fetch.
     */
    where?: EntregaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entregas to fetch.
     */
    orderBy?: EntregaOrderByWithRelationInput | EntregaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entregas.
     */
    cursor?: EntregaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entregas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entregas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entregas.
     */
    distinct?: EntregaScalarFieldEnum | EntregaScalarFieldEnum[]
  }


  /**
   * Entrega findMany
   */
  export type EntregaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * Filter, which Entregas to fetch.
     */
    where?: EntregaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entregas to fetch.
     */
    orderBy?: EntregaOrderByWithRelationInput | EntregaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entregas.
     */
    cursor?: EntregaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entregas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entregas.
     */
    skip?: number
    distinct?: EntregaScalarFieldEnum | EntregaScalarFieldEnum[]
  }


  /**
   * Entrega create
   */
  export type EntregaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * The data needed to create a Entrega.
     */
    data: XOR<EntregaCreateInput, EntregaUncheckedCreateInput>
  }


  /**
   * Entrega createMany
   */
  export type EntregaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entregas.
     */
    data: EntregaCreateManyInput | EntregaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Entrega update
   */
  export type EntregaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * The data needed to update a Entrega.
     */
    data: XOR<EntregaUpdateInput, EntregaUncheckedUpdateInput>
    /**
     * Choose, which Entrega to update.
     */
    where: EntregaWhereUniqueInput
  }


  /**
   * Entrega updateMany
   */
  export type EntregaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entregas.
     */
    data: XOR<EntregaUpdateManyMutationInput, EntregaUncheckedUpdateManyInput>
    /**
     * Filter which Entregas to update
     */
    where?: EntregaWhereInput
  }


  /**
   * Entrega upsert
   */
  export type EntregaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * The filter to search for the Entrega to update in case it exists.
     */
    where: EntregaWhereUniqueInput
    /**
     * In case the Entrega found by the `where` argument doesn't exist, create a new Entrega with this data.
     */
    create: XOR<EntregaCreateInput, EntregaUncheckedCreateInput>
    /**
     * In case the Entrega was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntregaUpdateInput, EntregaUncheckedUpdateInput>
  }


  /**
   * Entrega delete
   */
  export type EntregaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
    /**
     * Filter which Entrega to delete.
     */
    where: EntregaWhereUniqueInput
  }


  /**
   * Entrega deleteMany
   */
  export type EntregaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entregas to delete
     */
    where?: EntregaWhereInput
  }


  /**
   * Entrega.Correcao
   */
  export type Entrega$CorrecaoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    where?: CorrecaoWhereInput
  }


  /**
   * Entrega without action
   */
  export type EntregaDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entrega
     */
    select?: EntregaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EntregaInclude<ExtArgs> | null
  }



  /**
   * Model SolicitacaoSuporte
   */

  export type AggregateSolicitacaoSuporte = {
    _count: SolicitacaoSuporteCountAggregateOutputType | null
    _avg: SolicitacaoSuporteAvgAggregateOutputType | null
    _sum: SolicitacaoSuporteSumAggregateOutputType | null
    _min: SolicitacaoSuporteMinAggregateOutputType | null
    _max: SolicitacaoSuporteMaxAggregateOutputType | null
  }

  export type SolicitacaoSuporteAvgAggregateOutputType = {
    id: number | null
    codAluno: number | null
  }

  export type SolicitacaoSuporteSumAggregateOutputType = {
    id: number | null
    codAluno: number | null
  }

  export type SolicitacaoSuporteMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    conteudo: string | null
    dataCriacao: Date | null
    codAluno: number | null
  }

  export type SolicitacaoSuporteMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    conteudo: string | null
    dataCriacao: Date | null
    codAluno: number | null
  }

  export type SolicitacaoSuporteCountAggregateOutputType = {
    id: number
    titulo: number
    conteudo: number
    dataCriacao: number
    codAluno: number
    _all: number
  }


  export type SolicitacaoSuporteAvgAggregateInputType = {
    id?: true
    codAluno?: true
  }

  export type SolicitacaoSuporteSumAggregateInputType = {
    id?: true
    codAluno?: true
  }

  export type SolicitacaoSuporteMinAggregateInputType = {
    id?: true
    titulo?: true
    conteudo?: true
    dataCriacao?: true
    codAluno?: true
  }

  export type SolicitacaoSuporteMaxAggregateInputType = {
    id?: true
    titulo?: true
    conteudo?: true
    dataCriacao?: true
    codAluno?: true
  }

  export type SolicitacaoSuporteCountAggregateInputType = {
    id?: true
    titulo?: true
    conteudo?: true
    dataCriacao?: true
    codAluno?: true
    _all?: true
  }

  export type SolicitacaoSuporteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SolicitacaoSuporte to aggregate.
     */
    where?: SolicitacaoSuporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitacaoSuportes to fetch.
     */
    orderBy?: SolicitacaoSuporteOrderByWithRelationInput | SolicitacaoSuporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SolicitacaoSuporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitacaoSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitacaoSuportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SolicitacaoSuportes
    **/
    _count?: true | SolicitacaoSuporteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SolicitacaoSuporteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SolicitacaoSuporteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SolicitacaoSuporteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SolicitacaoSuporteMaxAggregateInputType
  }

  export type GetSolicitacaoSuporteAggregateType<T extends SolicitacaoSuporteAggregateArgs> = {
        [P in keyof T & keyof AggregateSolicitacaoSuporte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSolicitacaoSuporte[P]>
      : GetScalarType<T[P], AggregateSolicitacaoSuporte[P]>
  }




  export type SolicitacaoSuporteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SolicitacaoSuporteWhereInput
    orderBy?: SolicitacaoSuporteOrderByWithAggregationInput | SolicitacaoSuporteOrderByWithAggregationInput[]
    by: SolicitacaoSuporteScalarFieldEnum[] | SolicitacaoSuporteScalarFieldEnum
    having?: SolicitacaoSuporteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SolicitacaoSuporteCountAggregateInputType | true
    _avg?: SolicitacaoSuporteAvgAggregateInputType
    _sum?: SolicitacaoSuporteSumAggregateInputType
    _min?: SolicitacaoSuporteMinAggregateInputType
    _max?: SolicitacaoSuporteMaxAggregateInputType
  }

  export type SolicitacaoSuporteGroupByOutputType = {
    id: number
    titulo: string
    conteudo: string
    dataCriacao: Date
    codAluno: number
    _count: SolicitacaoSuporteCountAggregateOutputType | null
    _avg: SolicitacaoSuporteAvgAggregateOutputType | null
    _sum: SolicitacaoSuporteSumAggregateOutputType | null
    _min: SolicitacaoSuporteMinAggregateOutputType | null
    _max: SolicitacaoSuporteMaxAggregateOutputType | null
  }

  type GetSolicitacaoSuporteGroupByPayload<T extends SolicitacaoSuporteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SolicitacaoSuporteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SolicitacaoSuporteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SolicitacaoSuporteGroupByOutputType[P]>
            : GetScalarType<T[P], SolicitacaoSuporteGroupByOutputType[P]>
        }
      >
    >


  export type SolicitacaoSuporteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    conteudo?: boolean
    dataCriacao?: boolean
    codAluno?: boolean
    aluno?: boolean | UsuarioDefaultArgs<ExtArgs>
    Resposta?: boolean | SolicitacaoSuporte$RespostaArgs<ExtArgs>
  }, ExtArgs["result"]["solicitacaoSuporte"]>

  export type SolicitacaoSuporteSelectScalar = {
    id?: boolean
    titulo?: boolean
    conteudo?: boolean
    dataCriacao?: boolean
    codAluno?: boolean
  }

  export type SolicitacaoSuporteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    aluno?: boolean | UsuarioDefaultArgs<ExtArgs>
    Resposta?: boolean | SolicitacaoSuporte$RespostaArgs<ExtArgs>
  }


  export type $SolicitacaoSuportePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "SolicitacaoSuporte"
    objects: {
      aluno: Prisma.$UsuarioPayload<ExtArgs>
      Resposta: Prisma.$RespostaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: number
      titulo: string
      conteudo: string
      dataCriacao: Date
      codAluno: number
    }, ExtArgs["result"]["solicitacaoSuporte"]>
    composites: {}
  }


  type SolicitacaoSuporteGetPayload<S extends boolean | null | undefined | SolicitacaoSuporteDefaultArgs> = $Result.GetResult<Prisma.$SolicitacaoSuportePayload, S>

  type SolicitacaoSuporteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SolicitacaoSuporteFindManyArgs, 'select' | 'include'> & {
      select?: SolicitacaoSuporteCountAggregateInputType | true
    }

  export interface SolicitacaoSuporteDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SolicitacaoSuporte'], meta: { name: 'SolicitacaoSuporte' } }
    /**
     * Find zero or one SolicitacaoSuporte that matches the filter.
     * @param {SolicitacaoSuporteFindUniqueArgs} args - Arguments to find a SolicitacaoSuporte
     * @example
     * // Get one SolicitacaoSuporte
     * const solicitacaoSuporte = await prisma.solicitacaoSuporte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SolicitacaoSuporteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitacaoSuporteFindUniqueArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SolicitacaoSuporte that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SolicitacaoSuporteFindUniqueOrThrowArgs} args - Arguments to find a SolicitacaoSuporte
     * @example
     * // Get one SolicitacaoSuporte
     * const solicitacaoSuporte = await prisma.solicitacaoSuporte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SolicitacaoSuporteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitacaoSuporteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SolicitacaoSuporte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitacaoSuporteFindFirstArgs} args - Arguments to find a SolicitacaoSuporte
     * @example
     * // Get one SolicitacaoSuporte
     * const solicitacaoSuporte = await prisma.solicitacaoSuporte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SolicitacaoSuporteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitacaoSuporteFindFirstArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SolicitacaoSuporte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitacaoSuporteFindFirstOrThrowArgs} args - Arguments to find a SolicitacaoSuporte
     * @example
     * // Get one SolicitacaoSuporte
     * const solicitacaoSuporte = await prisma.solicitacaoSuporte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SolicitacaoSuporteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitacaoSuporteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SolicitacaoSuportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitacaoSuporteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SolicitacaoSuportes
     * const solicitacaoSuportes = await prisma.solicitacaoSuporte.findMany()
     * 
     * // Get first 10 SolicitacaoSuportes
     * const solicitacaoSuportes = await prisma.solicitacaoSuporte.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const solicitacaoSuporteWithIdOnly = await prisma.solicitacaoSuporte.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SolicitacaoSuporteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitacaoSuporteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SolicitacaoSuporte.
     * @param {SolicitacaoSuporteCreateArgs} args - Arguments to create a SolicitacaoSuporte.
     * @example
     * // Create one SolicitacaoSuporte
     * const SolicitacaoSuporte = await prisma.solicitacaoSuporte.create({
     *   data: {
     *     // ... data to create a SolicitacaoSuporte
     *   }
     * })
     * 
    **/
    create<T extends SolicitacaoSuporteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitacaoSuporteCreateArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SolicitacaoSuportes.
     *     @param {SolicitacaoSuporteCreateManyArgs} args - Arguments to create many SolicitacaoSuportes.
     *     @example
     *     // Create many SolicitacaoSuportes
     *     const solicitacaoSuporte = await prisma.solicitacaoSuporte.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SolicitacaoSuporteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitacaoSuporteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SolicitacaoSuporte.
     * @param {SolicitacaoSuporteDeleteArgs} args - Arguments to delete one SolicitacaoSuporte.
     * @example
     * // Delete one SolicitacaoSuporte
     * const SolicitacaoSuporte = await prisma.solicitacaoSuporte.delete({
     *   where: {
     *     // ... filter to delete one SolicitacaoSuporte
     *   }
     * })
     * 
    **/
    delete<T extends SolicitacaoSuporteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitacaoSuporteDeleteArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SolicitacaoSuporte.
     * @param {SolicitacaoSuporteUpdateArgs} args - Arguments to update one SolicitacaoSuporte.
     * @example
     * // Update one SolicitacaoSuporte
     * const solicitacaoSuporte = await prisma.solicitacaoSuporte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SolicitacaoSuporteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitacaoSuporteUpdateArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SolicitacaoSuportes.
     * @param {SolicitacaoSuporteDeleteManyArgs} args - Arguments to filter SolicitacaoSuportes to delete.
     * @example
     * // Delete a few SolicitacaoSuportes
     * const { count } = await prisma.solicitacaoSuporte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SolicitacaoSuporteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SolicitacaoSuporteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SolicitacaoSuportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitacaoSuporteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SolicitacaoSuportes
     * const solicitacaoSuporte = await prisma.solicitacaoSuporte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SolicitacaoSuporteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitacaoSuporteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SolicitacaoSuporte.
     * @param {SolicitacaoSuporteUpsertArgs} args - Arguments to update or create a SolicitacaoSuporte.
     * @example
     * // Update or create a SolicitacaoSuporte
     * const solicitacaoSuporte = await prisma.solicitacaoSuporte.upsert({
     *   create: {
     *     // ... data to create a SolicitacaoSuporte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SolicitacaoSuporte we want to update
     *   }
     * })
    **/
    upsert<T extends SolicitacaoSuporteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SolicitacaoSuporteUpsertArgs<ExtArgs>>
    ): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SolicitacaoSuportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitacaoSuporteCountArgs} args - Arguments to filter SolicitacaoSuportes to count.
     * @example
     * // Count the number of SolicitacaoSuportes
     * const count = await prisma.solicitacaoSuporte.count({
     *   where: {
     *     // ... the filter for the SolicitacaoSuportes we want to count
     *   }
     * })
    **/
    count<T extends SolicitacaoSuporteCountArgs>(
      args?: Subset<T, SolicitacaoSuporteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SolicitacaoSuporteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SolicitacaoSuporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitacaoSuporteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SolicitacaoSuporteAggregateArgs>(args: Subset<T, SolicitacaoSuporteAggregateArgs>): Prisma.PrismaPromise<GetSolicitacaoSuporteAggregateType<T>>

    /**
     * Group by SolicitacaoSuporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SolicitacaoSuporteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SolicitacaoSuporteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SolicitacaoSuporteGroupByArgs['orderBy'] }
        : { orderBy?: SolicitacaoSuporteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SolicitacaoSuporteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSolicitacaoSuporteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SolicitacaoSuporte model
   */
  readonly fields: SolicitacaoSuporteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SolicitacaoSuporte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SolicitacaoSuporteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    aluno<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Resposta<T extends SolicitacaoSuporte$RespostaArgs<ExtArgs> = {}>(args?: Subset<T, SolicitacaoSuporte$RespostaArgs<ExtArgs>>): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SolicitacaoSuporte model
   */ 
  interface SolicitacaoSuporteFieldRefs {
    readonly id: FieldRef<"SolicitacaoSuporte", 'Int'>
    readonly titulo: FieldRef<"SolicitacaoSuporte", 'String'>
    readonly conteudo: FieldRef<"SolicitacaoSuporte", 'String'>
    readonly dataCriacao: FieldRef<"SolicitacaoSuporte", 'DateTime'>
    readonly codAluno: FieldRef<"SolicitacaoSuporte", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SolicitacaoSuporte findUnique
   */
  export type SolicitacaoSuporteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * Filter, which SolicitacaoSuporte to fetch.
     */
    where: SolicitacaoSuporteWhereUniqueInput
  }


  /**
   * SolicitacaoSuporte findUniqueOrThrow
   */
  export type SolicitacaoSuporteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * Filter, which SolicitacaoSuporte to fetch.
     */
    where: SolicitacaoSuporteWhereUniqueInput
  }


  /**
   * SolicitacaoSuporte findFirst
   */
  export type SolicitacaoSuporteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * Filter, which SolicitacaoSuporte to fetch.
     */
    where?: SolicitacaoSuporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitacaoSuportes to fetch.
     */
    orderBy?: SolicitacaoSuporteOrderByWithRelationInput | SolicitacaoSuporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SolicitacaoSuportes.
     */
    cursor?: SolicitacaoSuporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitacaoSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitacaoSuportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SolicitacaoSuportes.
     */
    distinct?: SolicitacaoSuporteScalarFieldEnum | SolicitacaoSuporteScalarFieldEnum[]
  }


  /**
   * SolicitacaoSuporte findFirstOrThrow
   */
  export type SolicitacaoSuporteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * Filter, which SolicitacaoSuporte to fetch.
     */
    where?: SolicitacaoSuporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitacaoSuportes to fetch.
     */
    orderBy?: SolicitacaoSuporteOrderByWithRelationInput | SolicitacaoSuporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SolicitacaoSuportes.
     */
    cursor?: SolicitacaoSuporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitacaoSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitacaoSuportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SolicitacaoSuportes.
     */
    distinct?: SolicitacaoSuporteScalarFieldEnum | SolicitacaoSuporteScalarFieldEnum[]
  }


  /**
   * SolicitacaoSuporte findMany
   */
  export type SolicitacaoSuporteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * Filter, which SolicitacaoSuportes to fetch.
     */
    where?: SolicitacaoSuporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SolicitacaoSuportes to fetch.
     */
    orderBy?: SolicitacaoSuporteOrderByWithRelationInput | SolicitacaoSuporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SolicitacaoSuportes.
     */
    cursor?: SolicitacaoSuporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SolicitacaoSuportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SolicitacaoSuportes.
     */
    skip?: number
    distinct?: SolicitacaoSuporteScalarFieldEnum | SolicitacaoSuporteScalarFieldEnum[]
  }


  /**
   * SolicitacaoSuporte create
   */
  export type SolicitacaoSuporteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * The data needed to create a SolicitacaoSuporte.
     */
    data: XOR<SolicitacaoSuporteCreateInput, SolicitacaoSuporteUncheckedCreateInput>
  }


  /**
   * SolicitacaoSuporte createMany
   */
  export type SolicitacaoSuporteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SolicitacaoSuportes.
     */
    data: SolicitacaoSuporteCreateManyInput | SolicitacaoSuporteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SolicitacaoSuporte update
   */
  export type SolicitacaoSuporteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * The data needed to update a SolicitacaoSuporte.
     */
    data: XOR<SolicitacaoSuporteUpdateInput, SolicitacaoSuporteUncheckedUpdateInput>
    /**
     * Choose, which SolicitacaoSuporte to update.
     */
    where: SolicitacaoSuporteWhereUniqueInput
  }


  /**
   * SolicitacaoSuporte updateMany
   */
  export type SolicitacaoSuporteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SolicitacaoSuportes.
     */
    data: XOR<SolicitacaoSuporteUpdateManyMutationInput, SolicitacaoSuporteUncheckedUpdateManyInput>
    /**
     * Filter which SolicitacaoSuportes to update
     */
    where?: SolicitacaoSuporteWhereInput
  }


  /**
   * SolicitacaoSuporte upsert
   */
  export type SolicitacaoSuporteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * The filter to search for the SolicitacaoSuporte to update in case it exists.
     */
    where: SolicitacaoSuporteWhereUniqueInput
    /**
     * In case the SolicitacaoSuporte found by the `where` argument doesn't exist, create a new SolicitacaoSuporte with this data.
     */
    create: XOR<SolicitacaoSuporteCreateInput, SolicitacaoSuporteUncheckedCreateInput>
    /**
     * In case the SolicitacaoSuporte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SolicitacaoSuporteUpdateInput, SolicitacaoSuporteUncheckedUpdateInput>
  }


  /**
   * SolicitacaoSuporte delete
   */
  export type SolicitacaoSuporteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
    /**
     * Filter which SolicitacaoSuporte to delete.
     */
    where: SolicitacaoSuporteWhereUniqueInput
  }


  /**
   * SolicitacaoSuporte deleteMany
   */
  export type SolicitacaoSuporteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SolicitacaoSuportes to delete
     */
    where?: SolicitacaoSuporteWhereInput
  }


  /**
   * SolicitacaoSuporte.Resposta
   */
  export type SolicitacaoSuporte$RespostaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    where?: RespostaWhereInput
  }


  /**
   * SolicitacaoSuporte without action
   */
  export type SolicitacaoSuporteDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SolicitacaoSuporte
     */
    select?: SolicitacaoSuporteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SolicitacaoSuporteInclude<ExtArgs> | null
  }



  /**
   * Model Resposta
   */

  export type AggregateResposta = {
    _count: RespostaCountAggregateOutputType | null
    _avg: RespostaAvgAggregateOutputType | null
    _sum: RespostaSumAggregateOutputType | null
    _min: RespostaMinAggregateOutputType | null
    _max: RespostaMaxAggregateOutputType | null
  }

  export type RespostaAvgAggregateOutputType = {
    id: number | null
    codCoordenador: number | null
    codSolicitacao: number | null
  }

  export type RespostaSumAggregateOutputType = {
    id: number | null
    codCoordenador: number | null
    codSolicitacao: number | null
  }

  export type RespostaMinAggregateOutputType = {
    id: number | null
    dataResposta: Date | null
    resposta: string | null
    codCoordenador: number | null
    codSolicitacao: number | null
  }

  export type RespostaMaxAggregateOutputType = {
    id: number | null
    dataResposta: Date | null
    resposta: string | null
    codCoordenador: number | null
    codSolicitacao: number | null
  }

  export type RespostaCountAggregateOutputType = {
    id: number
    dataResposta: number
    resposta: number
    codCoordenador: number
    codSolicitacao: number
    _all: number
  }


  export type RespostaAvgAggregateInputType = {
    id?: true
    codCoordenador?: true
    codSolicitacao?: true
  }

  export type RespostaSumAggregateInputType = {
    id?: true
    codCoordenador?: true
    codSolicitacao?: true
  }

  export type RespostaMinAggregateInputType = {
    id?: true
    dataResposta?: true
    resposta?: true
    codCoordenador?: true
    codSolicitacao?: true
  }

  export type RespostaMaxAggregateInputType = {
    id?: true
    dataResposta?: true
    resposta?: true
    codCoordenador?: true
    codSolicitacao?: true
  }

  export type RespostaCountAggregateInputType = {
    id?: true
    dataResposta?: true
    resposta?: true
    codCoordenador?: true
    codSolicitacao?: true
    _all?: true
  }

  export type RespostaAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resposta to aggregate.
     */
    where?: RespostaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respostas to fetch.
     */
    orderBy?: RespostaOrderByWithRelationInput | RespostaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RespostaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respostas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Respostas
    **/
    _count?: true | RespostaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RespostaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RespostaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RespostaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RespostaMaxAggregateInputType
  }

  export type GetRespostaAggregateType<T extends RespostaAggregateArgs> = {
        [P in keyof T & keyof AggregateResposta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResposta[P]>
      : GetScalarType<T[P], AggregateResposta[P]>
  }




  export type RespostaGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RespostaWhereInput
    orderBy?: RespostaOrderByWithAggregationInput | RespostaOrderByWithAggregationInput[]
    by: RespostaScalarFieldEnum[] | RespostaScalarFieldEnum
    having?: RespostaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RespostaCountAggregateInputType | true
    _avg?: RespostaAvgAggregateInputType
    _sum?: RespostaSumAggregateInputType
    _min?: RespostaMinAggregateInputType
    _max?: RespostaMaxAggregateInputType
  }

  export type RespostaGroupByOutputType = {
    id: number
    dataResposta: Date
    resposta: string
    codCoordenador: number
    codSolicitacao: number
    _count: RespostaCountAggregateOutputType | null
    _avg: RespostaAvgAggregateOutputType | null
    _sum: RespostaSumAggregateOutputType | null
    _min: RespostaMinAggregateOutputType | null
    _max: RespostaMaxAggregateOutputType | null
  }

  type GetRespostaGroupByPayload<T extends RespostaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RespostaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RespostaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RespostaGroupByOutputType[P]>
            : GetScalarType<T[P], RespostaGroupByOutputType[P]>
        }
      >
    >


  export type RespostaSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dataResposta?: boolean
    resposta?: boolean
    codCoordenador?: boolean
    codSolicitacao?: boolean
    coordenador?: boolean | UsuarioDefaultArgs<ExtArgs>
    solicitacaoSuporte?: boolean | SolicitacaoSuporteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resposta"]>

  export type RespostaSelectScalar = {
    id?: boolean
    dataResposta?: boolean
    resposta?: boolean
    codCoordenador?: boolean
    codSolicitacao?: boolean
  }

  export type RespostaInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    coordenador?: boolean | UsuarioDefaultArgs<ExtArgs>
    solicitacaoSuporte?: boolean | SolicitacaoSuporteDefaultArgs<ExtArgs>
  }


  export type $RespostaPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Resposta"
    objects: {
      coordenador: Prisma.$UsuarioPayload<ExtArgs>
      solicitacaoSuporte: Prisma.$SolicitacaoSuportePayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      dataResposta: Date
      resposta: string
      codCoordenador: number
      codSolicitacao: number
    }, ExtArgs["result"]["resposta"]>
    composites: {}
  }


  type RespostaGetPayload<S extends boolean | null | undefined | RespostaDefaultArgs> = $Result.GetResult<Prisma.$RespostaPayload, S>

  type RespostaCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RespostaFindManyArgs, 'select' | 'include'> & {
      select?: RespostaCountAggregateInputType | true
    }

  export interface RespostaDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resposta'], meta: { name: 'Resposta' } }
    /**
     * Find zero or one Resposta that matches the filter.
     * @param {RespostaFindUniqueArgs} args - Arguments to find a Resposta
     * @example
     * // Get one Resposta
     * const resposta = await prisma.resposta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RespostaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RespostaFindUniqueArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Resposta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RespostaFindUniqueOrThrowArgs} args - Arguments to find a Resposta
     * @example
     * // Get one Resposta
     * const resposta = await prisma.resposta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RespostaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RespostaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Resposta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespostaFindFirstArgs} args - Arguments to find a Resposta
     * @example
     * // Get one Resposta
     * const resposta = await prisma.resposta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RespostaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RespostaFindFirstArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Resposta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespostaFindFirstOrThrowArgs} args - Arguments to find a Resposta
     * @example
     * // Get one Resposta
     * const resposta = await prisma.resposta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RespostaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RespostaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Respostas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespostaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Respostas
     * const respostas = await prisma.resposta.findMany()
     * 
     * // Get first 10 Respostas
     * const respostas = await prisma.resposta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const respostaWithIdOnly = await prisma.resposta.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RespostaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RespostaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Resposta.
     * @param {RespostaCreateArgs} args - Arguments to create a Resposta.
     * @example
     * // Create one Resposta
     * const Resposta = await prisma.resposta.create({
     *   data: {
     *     // ... data to create a Resposta
     *   }
     * })
     * 
    **/
    create<T extends RespostaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RespostaCreateArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Respostas.
     *     @param {RespostaCreateManyArgs} args - Arguments to create many Respostas.
     *     @example
     *     // Create many Respostas
     *     const resposta = await prisma.resposta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RespostaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RespostaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resposta.
     * @param {RespostaDeleteArgs} args - Arguments to delete one Resposta.
     * @example
     * // Delete one Resposta
     * const Resposta = await prisma.resposta.delete({
     *   where: {
     *     // ... filter to delete one Resposta
     *   }
     * })
     * 
    **/
    delete<T extends RespostaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RespostaDeleteArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Resposta.
     * @param {RespostaUpdateArgs} args - Arguments to update one Resposta.
     * @example
     * // Update one Resposta
     * const resposta = await prisma.resposta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RespostaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RespostaUpdateArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Respostas.
     * @param {RespostaDeleteManyArgs} args - Arguments to filter Respostas to delete.
     * @example
     * // Delete a few Respostas
     * const { count } = await prisma.resposta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RespostaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RespostaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Respostas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespostaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Respostas
     * const resposta = await prisma.resposta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RespostaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RespostaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resposta.
     * @param {RespostaUpsertArgs} args - Arguments to update or create a Resposta.
     * @example
     * // Update or create a Resposta
     * const resposta = await prisma.resposta.upsert({
     *   create: {
     *     // ... data to create a Resposta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resposta we want to update
     *   }
     * })
    **/
    upsert<T extends RespostaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RespostaUpsertArgs<ExtArgs>>
    ): Prisma__RespostaClient<$Result.GetResult<Prisma.$RespostaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Respostas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespostaCountArgs} args - Arguments to filter Respostas to count.
     * @example
     * // Count the number of Respostas
     * const count = await prisma.resposta.count({
     *   where: {
     *     // ... the filter for the Respostas we want to count
     *   }
     * })
    **/
    count<T extends RespostaCountArgs>(
      args?: Subset<T, RespostaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RespostaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resposta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespostaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RespostaAggregateArgs>(args: Subset<T, RespostaAggregateArgs>): Prisma.PrismaPromise<GetRespostaAggregateType<T>>

    /**
     * Group by Resposta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespostaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RespostaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RespostaGroupByArgs['orderBy'] }
        : { orderBy?: RespostaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RespostaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRespostaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resposta model
   */
  readonly fields: RespostaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resposta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RespostaClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    coordenador<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    solicitacaoSuporte<T extends SolicitacaoSuporteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SolicitacaoSuporteDefaultArgs<ExtArgs>>): Prisma__SolicitacaoSuporteClient<$Result.GetResult<Prisma.$SolicitacaoSuportePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Resposta model
   */ 
  interface RespostaFieldRefs {
    readonly id: FieldRef<"Resposta", 'Int'>
    readonly dataResposta: FieldRef<"Resposta", 'DateTime'>
    readonly resposta: FieldRef<"Resposta", 'String'>
    readonly codCoordenador: FieldRef<"Resposta", 'Int'>
    readonly codSolicitacao: FieldRef<"Resposta", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Resposta findUnique
   */
  export type RespostaFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * Filter, which Resposta to fetch.
     */
    where: RespostaWhereUniqueInput
  }


  /**
   * Resposta findUniqueOrThrow
   */
  export type RespostaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * Filter, which Resposta to fetch.
     */
    where: RespostaWhereUniqueInput
  }


  /**
   * Resposta findFirst
   */
  export type RespostaFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * Filter, which Resposta to fetch.
     */
    where?: RespostaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respostas to fetch.
     */
    orderBy?: RespostaOrderByWithRelationInput | RespostaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Respostas.
     */
    cursor?: RespostaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respostas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Respostas.
     */
    distinct?: RespostaScalarFieldEnum | RespostaScalarFieldEnum[]
  }


  /**
   * Resposta findFirstOrThrow
   */
  export type RespostaFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * Filter, which Resposta to fetch.
     */
    where?: RespostaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respostas to fetch.
     */
    orderBy?: RespostaOrderByWithRelationInput | RespostaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Respostas.
     */
    cursor?: RespostaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respostas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Respostas.
     */
    distinct?: RespostaScalarFieldEnum | RespostaScalarFieldEnum[]
  }


  /**
   * Resposta findMany
   */
  export type RespostaFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * Filter, which Respostas to fetch.
     */
    where?: RespostaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Respostas to fetch.
     */
    orderBy?: RespostaOrderByWithRelationInput | RespostaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Respostas.
     */
    cursor?: RespostaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Respostas.
     */
    skip?: number
    distinct?: RespostaScalarFieldEnum | RespostaScalarFieldEnum[]
  }


  /**
   * Resposta create
   */
  export type RespostaCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * The data needed to create a Resposta.
     */
    data: XOR<RespostaCreateInput, RespostaUncheckedCreateInput>
  }


  /**
   * Resposta createMany
   */
  export type RespostaCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Respostas.
     */
    data: RespostaCreateManyInput | RespostaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Resposta update
   */
  export type RespostaUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * The data needed to update a Resposta.
     */
    data: XOR<RespostaUpdateInput, RespostaUncheckedUpdateInput>
    /**
     * Choose, which Resposta to update.
     */
    where: RespostaWhereUniqueInput
  }


  /**
   * Resposta updateMany
   */
  export type RespostaUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Respostas.
     */
    data: XOR<RespostaUpdateManyMutationInput, RespostaUncheckedUpdateManyInput>
    /**
     * Filter which Respostas to update
     */
    where?: RespostaWhereInput
  }


  /**
   * Resposta upsert
   */
  export type RespostaUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * The filter to search for the Resposta to update in case it exists.
     */
    where: RespostaWhereUniqueInput
    /**
     * In case the Resposta found by the `where` argument doesn't exist, create a new Resposta with this data.
     */
    create: XOR<RespostaCreateInput, RespostaUncheckedCreateInput>
    /**
     * In case the Resposta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RespostaUpdateInput, RespostaUncheckedUpdateInput>
  }


  /**
   * Resposta delete
   */
  export type RespostaDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
    /**
     * Filter which Resposta to delete.
     */
    where: RespostaWhereUniqueInput
  }


  /**
   * Resposta deleteMany
   */
  export type RespostaDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Respostas to delete
     */
    where?: RespostaWhereInput
  }


  /**
   * Resposta without action
   */
  export type RespostaDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resposta
     */
    select?: RespostaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RespostaInclude<ExtArgs> | null
  }



  /**
   * Model Correcao
   */

  export type AggregateCorrecao = {
    _count: CorrecaoCountAggregateOutputType | null
    _avg: CorrecaoAvgAggregateOutputType | null
    _sum: CorrecaoSumAggregateOutputType | null
    _min: CorrecaoMinAggregateOutputType | null
    _max: CorrecaoMaxAggregateOutputType | null
  }

  export type CorrecaoAvgAggregateOutputType = {
    id: number | null
    codCoordenador: number | null
    codEntrega: number | null
  }

  export type CorrecaoSumAggregateOutputType = {
    id: number | null
    codCoordenador: number | null
    codEntrega: number | null
  }

  export type CorrecaoMinAggregateOutputType = {
    id: number | null
    dataCorrecao: Date | null
    conteudo: string | null
    codCoordenador: number | null
    codEntrega: number | null
  }

  export type CorrecaoMaxAggregateOutputType = {
    id: number | null
    dataCorrecao: Date | null
    conteudo: string | null
    codCoordenador: number | null
    codEntrega: number | null
  }

  export type CorrecaoCountAggregateOutputType = {
    id: number
    dataCorrecao: number
    conteudo: number
    codCoordenador: number
    codEntrega: number
    _all: number
  }


  export type CorrecaoAvgAggregateInputType = {
    id?: true
    codCoordenador?: true
    codEntrega?: true
  }

  export type CorrecaoSumAggregateInputType = {
    id?: true
    codCoordenador?: true
    codEntrega?: true
  }

  export type CorrecaoMinAggregateInputType = {
    id?: true
    dataCorrecao?: true
    conteudo?: true
    codCoordenador?: true
    codEntrega?: true
  }

  export type CorrecaoMaxAggregateInputType = {
    id?: true
    dataCorrecao?: true
    conteudo?: true
    codCoordenador?: true
    codEntrega?: true
  }

  export type CorrecaoCountAggregateInputType = {
    id?: true
    dataCorrecao?: true
    conteudo?: true
    codCoordenador?: true
    codEntrega?: true
    _all?: true
  }

  export type CorrecaoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Correcao to aggregate.
     */
    where?: CorrecaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correcaos to fetch.
     */
    orderBy?: CorrecaoOrderByWithRelationInput | CorrecaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorrecaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correcaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Correcaos
    **/
    _count?: true | CorrecaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorrecaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorrecaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorrecaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorrecaoMaxAggregateInputType
  }

  export type GetCorrecaoAggregateType<T extends CorrecaoAggregateArgs> = {
        [P in keyof T & keyof AggregateCorrecao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorrecao[P]>
      : GetScalarType<T[P], AggregateCorrecao[P]>
  }




  export type CorrecaoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CorrecaoWhereInput
    orderBy?: CorrecaoOrderByWithAggregationInput | CorrecaoOrderByWithAggregationInput[]
    by: CorrecaoScalarFieldEnum[] | CorrecaoScalarFieldEnum
    having?: CorrecaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorrecaoCountAggregateInputType | true
    _avg?: CorrecaoAvgAggregateInputType
    _sum?: CorrecaoSumAggregateInputType
    _min?: CorrecaoMinAggregateInputType
    _max?: CorrecaoMaxAggregateInputType
  }

  export type CorrecaoGroupByOutputType = {
    id: number
    dataCorrecao: Date
    conteudo: string
    codCoordenador: number
    codEntrega: number
    _count: CorrecaoCountAggregateOutputType | null
    _avg: CorrecaoAvgAggregateOutputType | null
    _sum: CorrecaoSumAggregateOutputType | null
    _min: CorrecaoMinAggregateOutputType | null
    _max: CorrecaoMaxAggregateOutputType | null
  }

  type GetCorrecaoGroupByPayload<T extends CorrecaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorrecaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorrecaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorrecaoGroupByOutputType[P]>
            : GetScalarType<T[P], CorrecaoGroupByOutputType[P]>
        }
      >
    >


  export type CorrecaoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dataCorrecao?: boolean
    conteudo?: boolean
    codCoordenador?: boolean
    codEntrega?: boolean
    coordenador?: boolean | UsuarioDefaultArgs<ExtArgs>
    entrega?: boolean | EntregaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["correcao"]>

  export type CorrecaoSelectScalar = {
    id?: boolean
    dataCorrecao?: boolean
    conteudo?: boolean
    codCoordenador?: boolean
    codEntrega?: boolean
  }

  export type CorrecaoInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    coordenador?: boolean | UsuarioDefaultArgs<ExtArgs>
    entrega?: boolean | EntregaDefaultArgs<ExtArgs>
  }


  export type $CorrecaoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Correcao"
    objects: {
      coordenador: Prisma.$UsuarioPayload<ExtArgs>
      entrega: Prisma.$EntregaPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      dataCorrecao: Date
      conteudo: string
      codCoordenador: number
      codEntrega: number
    }, ExtArgs["result"]["correcao"]>
    composites: {}
  }


  type CorrecaoGetPayload<S extends boolean | null | undefined | CorrecaoDefaultArgs> = $Result.GetResult<Prisma.$CorrecaoPayload, S>

  type CorrecaoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CorrecaoFindManyArgs, 'select' | 'include'> & {
      select?: CorrecaoCountAggregateInputType | true
    }

  export interface CorrecaoDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Correcao'], meta: { name: 'Correcao' } }
    /**
     * Find zero or one Correcao that matches the filter.
     * @param {CorrecaoFindUniqueArgs} args - Arguments to find a Correcao
     * @example
     * // Get one Correcao
     * const correcao = await prisma.correcao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CorrecaoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CorrecaoFindUniqueArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Correcao that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CorrecaoFindUniqueOrThrowArgs} args - Arguments to find a Correcao
     * @example
     * // Get one Correcao
     * const correcao = await prisma.correcao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CorrecaoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CorrecaoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Correcao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrecaoFindFirstArgs} args - Arguments to find a Correcao
     * @example
     * // Get one Correcao
     * const correcao = await prisma.correcao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CorrecaoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CorrecaoFindFirstArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Correcao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrecaoFindFirstOrThrowArgs} args - Arguments to find a Correcao
     * @example
     * // Get one Correcao
     * const correcao = await prisma.correcao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CorrecaoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CorrecaoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Correcaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrecaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Correcaos
     * const correcaos = await prisma.correcao.findMany()
     * 
     * // Get first 10 Correcaos
     * const correcaos = await prisma.correcao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const correcaoWithIdOnly = await prisma.correcao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CorrecaoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CorrecaoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Correcao.
     * @param {CorrecaoCreateArgs} args - Arguments to create a Correcao.
     * @example
     * // Create one Correcao
     * const Correcao = await prisma.correcao.create({
     *   data: {
     *     // ... data to create a Correcao
     *   }
     * })
     * 
    **/
    create<T extends CorrecaoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CorrecaoCreateArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Correcaos.
     *     @param {CorrecaoCreateManyArgs} args - Arguments to create many Correcaos.
     *     @example
     *     // Create many Correcaos
     *     const correcao = await prisma.correcao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CorrecaoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CorrecaoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Correcao.
     * @param {CorrecaoDeleteArgs} args - Arguments to delete one Correcao.
     * @example
     * // Delete one Correcao
     * const Correcao = await prisma.correcao.delete({
     *   where: {
     *     // ... filter to delete one Correcao
     *   }
     * })
     * 
    **/
    delete<T extends CorrecaoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CorrecaoDeleteArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Correcao.
     * @param {CorrecaoUpdateArgs} args - Arguments to update one Correcao.
     * @example
     * // Update one Correcao
     * const correcao = await prisma.correcao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CorrecaoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CorrecaoUpdateArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Correcaos.
     * @param {CorrecaoDeleteManyArgs} args - Arguments to filter Correcaos to delete.
     * @example
     * // Delete a few Correcaos
     * const { count } = await prisma.correcao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CorrecaoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CorrecaoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Correcaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrecaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Correcaos
     * const correcao = await prisma.correcao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CorrecaoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CorrecaoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Correcao.
     * @param {CorrecaoUpsertArgs} args - Arguments to update or create a Correcao.
     * @example
     * // Update or create a Correcao
     * const correcao = await prisma.correcao.upsert({
     *   create: {
     *     // ... data to create a Correcao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Correcao we want to update
     *   }
     * })
    **/
    upsert<T extends CorrecaoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CorrecaoUpsertArgs<ExtArgs>>
    ): Prisma__CorrecaoClient<$Result.GetResult<Prisma.$CorrecaoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Correcaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrecaoCountArgs} args - Arguments to filter Correcaos to count.
     * @example
     * // Count the number of Correcaos
     * const count = await prisma.correcao.count({
     *   where: {
     *     // ... the filter for the Correcaos we want to count
     *   }
     * })
    **/
    count<T extends CorrecaoCountArgs>(
      args?: Subset<T, CorrecaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorrecaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Correcao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrecaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorrecaoAggregateArgs>(args: Subset<T, CorrecaoAggregateArgs>): Prisma.PrismaPromise<GetCorrecaoAggregateType<T>>

    /**
     * Group by Correcao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrecaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorrecaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorrecaoGroupByArgs['orderBy'] }
        : { orderBy?: CorrecaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorrecaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorrecaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Correcao model
   */
  readonly fields: CorrecaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Correcao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorrecaoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    coordenador<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    entrega<T extends EntregaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntregaDefaultArgs<ExtArgs>>): Prisma__EntregaClient<$Result.GetResult<Prisma.$EntregaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Correcao model
   */ 
  interface CorrecaoFieldRefs {
    readonly id: FieldRef<"Correcao", 'Int'>
    readonly dataCorrecao: FieldRef<"Correcao", 'DateTime'>
    readonly conteudo: FieldRef<"Correcao", 'String'>
    readonly codCoordenador: FieldRef<"Correcao", 'Int'>
    readonly codEntrega: FieldRef<"Correcao", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Correcao findUnique
   */
  export type CorrecaoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * Filter, which Correcao to fetch.
     */
    where: CorrecaoWhereUniqueInput
  }


  /**
   * Correcao findUniqueOrThrow
   */
  export type CorrecaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * Filter, which Correcao to fetch.
     */
    where: CorrecaoWhereUniqueInput
  }


  /**
   * Correcao findFirst
   */
  export type CorrecaoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * Filter, which Correcao to fetch.
     */
    where?: CorrecaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correcaos to fetch.
     */
    orderBy?: CorrecaoOrderByWithRelationInput | CorrecaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Correcaos.
     */
    cursor?: CorrecaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correcaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Correcaos.
     */
    distinct?: CorrecaoScalarFieldEnum | CorrecaoScalarFieldEnum[]
  }


  /**
   * Correcao findFirstOrThrow
   */
  export type CorrecaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * Filter, which Correcao to fetch.
     */
    where?: CorrecaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correcaos to fetch.
     */
    orderBy?: CorrecaoOrderByWithRelationInput | CorrecaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Correcaos.
     */
    cursor?: CorrecaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correcaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Correcaos.
     */
    distinct?: CorrecaoScalarFieldEnum | CorrecaoScalarFieldEnum[]
  }


  /**
   * Correcao findMany
   */
  export type CorrecaoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * Filter, which Correcaos to fetch.
     */
    where?: CorrecaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correcaos to fetch.
     */
    orderBy?: CorrecaoOrderByWithRelationInput | CorrecaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Correcaos.
     */
    cursor?: CorrecaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correcaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correcaos.
     */
    skip?: number
    distinct?: CorrecaoScalarFieldEnum | CorrecaoScalarFieldEnum[]
  }


  /**
   * Correcao create
   */
  export type CorrecaoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Correcao.
     */
    data: XOR<CorrecaoCreateInput, CorrecaoUncheckedCreateInput>
  }


  /**
   * Correcao createMany
   */
  export type CorrecaoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Correcaos.
     */
    data: CorrecaoCreateManyInput | CorrecaoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Correcao update
   */
  export type CorrecaoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Correcao.
     */
    data: XOR<CorrecaoUpdateInput, CorrecaoUncheckedUpdateInput>
    /**
     * Choose, which Correcao to update.
     */
    where: CorrecaoWhereUniqueInput
  }


  /**
   * Correcao updateMany
   */
  export type CorrecaoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Correcaos.
     */
    data: XOR<CorrecaoUpdateManyMutationInput, CorrecaoUncheckedUpdateManyInput>
    /**
     * Filter which Correcaos to update
     */
    where?: CorrecaoWhereInput
  }


  /**
   * Correcao upsert
   */
  export type CorrecaoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Correcao to update in case it exists.
     */
    where: CorrecaoWhereUniqueInput
    /**
     * In case the Correcao found by the `where` argument doesn't exist, create a new Correcao with this data.
     */
    create: XOR<CorrecaoCreateInput, CorrecaoUncheckedCreateInput>
    /**
     * In case the Correcao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorrecaoUpdateInput, CorrecaoUncheckedUpdateInput>
  }


  /**
   * Correcao delete
   */
  export type CorrecaoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
    /**
     * Filter which Correcao to delete.
     */
    where: CorrecaoWhereUniqueInput
  }


  /**
   * Correcao deleteMany
   */
  export type CorrecaoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Correcaos to delete
     */
    where?: CorrecaoWhereInput
  }


  /**
   * Correcao without action
   */
  export type CorrecaoDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correcao
     */
    select?: CorrecaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CorrecaoInclude<ExtArgs> | null
  }



  /**
   * Model Horas
   */

  export type AggregateHoras = {
    _count: HorasCountAggregateOutputType | null
    _avg: HorasAvgAggregateOutputType | null
    _sum: HorasSumAggregateOutputType | null
    _min: HorasMinAggregateOutputType | null
    _max: HorasMaxAggregateOutputType | null
  }

  export type HorasAvgAggregateOutputType = {
    id: number | null
    horasAnuais: number | null
    horasConcluidas: number | null
    ano: number | null
    codAluno: number | null
  }

  export type HorasSumAggregateOutputType = {
    id: number | null
    horasAnuais: number | null
    horasConcluidas: number | null
    ano: number | null
    codAluno: number | null
  }

  export type HorasMinAggregateOutputType = {
    id: number | null
    horasAnuais: number | null
    horasConcluidas: number | null
    ano: number | null
    codAluno: number | null
  }

  export type HorasMaxAggregateOutputType = {
    id: number | null
    horasAnuais: number | null
    horasConcluidas: number | null
    ano: number | null
    codAluno: number | null
  }

  export type HorasCountAggregateOutputType = {
    id: number
    horasAnuais: number
    horasConcluidas: number
    ano: number
    codAluno: number
    _all: number
  }


  export type HorasAvgAggregateInputType = {
    id?: true
    horasAnuais?: true
    horasConcluidas?: true
    ano?: true
    codAluno?: true
  }

  export type HorasSumAggregateInputType = {
    id?: true
    horasAnuais?: true
    horasConcluidas?: true
    ano?: true
    codAluno?: true
  }

  export type HorasMinAggregateInputType = {
    id?: true
    horasAnuais?: true
    horasConcluidas?: true
    ano?: true
    codAluno?: true
  }

  export type HorasMaxAggregateInputType = {
    id?: true
    horasAnuais?: true
    horasConcluidas?: true
    ano?: true
    codAluno?: true
  }

  export type HorasCountAggregateInputType = {
    id?: true
    horasAnuais?: true
    horasConcluidas?: true
    ano?: true
    codAluno?: true
    _all?: true
  }

  export type HorasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Horas to aggregate.
     */
    where?: HorasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horas to fetch.
     */
    orderBy?: HorasOrderByWithRelationInput | HorasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HorasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Horas
    **/
    _count?: true | HorasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HorasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HorasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HorasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HorasMaxAggregateInputType
  }

  export type GetHorasAggregateType<T extends HorasAggregateArgs> = {
        [P in keyof T & keyof AggregateHoras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoras[P]>
      : GetScalarType<T[P], AggregateHoras[P]>
  }




  export type HorasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: HorasWhereInput
    orderBy?: HorasOrderByWithAggregationInput | HorasOrderByWithAggregationInput[]
    by: HorasScalarFieldEnum[] | HorasScalarFieldEnum
    having?: HorasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HorasCountAggregateInputType | true
    _avg?: HorasAvgAggregateInputType
    _sum?: HorasSumAggregateInputType
    _min?: HorasMinAggregateInputType
    _max?: HorasMaxAggregateInputType
  }

  export type HorasGroupByOutputType = {
    id: number
    horasAnuais: number
    horasConcluidas: number
    ano: number
    codAluno: number
    _count: HorasCountAggregateOutputType | null
    _avg: HorasAvgAggregateOutputType | null
    _sum: HorasSumAggregateOutputType | null
    _min: HorasMinAggregateOutputType | null
    _max: HorasMaxAggregateOutputType | null
  }

  type GetHorasGroupByPayload<T extends HorasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HorasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HorasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HorasGroupByOutputType[P]>
            : GetScalarType<T[P], HorasGroupByOutputType[P]>
        }
      >
    >


  export type HorasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    horasAnuais?: boolean
    horasConcluidas?: boolean
    ano?: boolean
    codAluno?: boolean
    aluno?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["horas"]>

  export type HorasSelectScalar = {
    id?: boolean
    horasAnuais?: boolean
    horasConcluidas?: boolean
    ano?: boolean
    codAluno?: boolean
  }

  export type HorasInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    aluno?: boolean | UsuarioDefaultArgs<ExtArgs>
  }


  export type $HorasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Horas"
    objects: {
      aluno: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      horasAnuais: number
      horasConcluidas: number
      ano: number
      codAluno: number
    }, ExtArgs["result"]["horas"]>
    composites: {}
  }


  type HorasGetPayload<S extends boolean | null | undefined | HorasDefaultArgs> = $Result.GetResult<Prisma.$HorasPayload, S>

  type HorasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<HorasFindManyArgs, 'select' | 'include'> & {
      select?: HorasCountAggregateInputType | true
    }

  export interface HorasDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Horas'], meta: { name: 'Horas' } }
    /**
     * Find zero or one Horas that matches the filter.
     * @param {HorasFindUniqueArgs} args - Arguments to find a Horas
     * @example
     * // Get one Horas
     * const horas = await prisma.horas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HorasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HorasFindUniqueArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Horas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HorasFindUniqueOrThrowArgs} args - Arguments to find a Horas
     * @example
     * // Get one Horas
     * const horas = await prisma.horas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HorasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Horas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasFindFirstArgs} args - Arguments to find a Horas
     * @example
     * // Get one Horas
     * const horas = await prisma.horas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HorasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasFindFirstArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Horas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasFindFirstOrThrowArgs} args - Arguments to find a Horas
     * @example
     * // Get one Horas
     * const horas = await prisma.horas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HorasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Horas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Horas
     * const horas = await prisma.horas.findMany()
     * 
     * // Get first 10 Horas
     * const horas = await prisma.horas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const horasWithIdOnly = await prisma.horas.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HorasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Horas.
     * @param {HorasCreateArgs} args - Arguments to create a Horas.
     * @example
     * // Create one Horas
     * const Horas = await prisma.horas.create({
     *   data: {
     *     // ... data to create a Horas
     *   }
     * })
     * 
    **/
    create<T extends HorasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HorasCreateArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Horas.
     *     @param {HorasCreateManyArgs} args - Arguments to create many Horas.
     *     @example
     *     // Create many Horas
     *     const horas = await prisma.horas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HorasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Horas.
     * @param {HorasDeleteArgs} args - Arguments to delete one Horas.
     * @example
     * // Delete one Horas
     * const Horas = await prisma.horas.delete({
     *   where: {
     *     // ... filter to delete one Horas
     *   }
     * })
     * 
    **/
    delete<T extends HorasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HorasDeleteArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Horas.
     * @param {HorasUpdateArgs} args - Arguments to update one Horas.
     * @example
     * // Update one Horas
     * const horas = await prisma.horas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HorasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HorasUpdateArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Horas.
     * @param {HorasDeleteManyArgs} args - Arguments to filter Horas to delete.
     * @example
     * // Delete a few Horas
     * const { count } = await prisma.horas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HorasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HorasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Horas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Horas
     * const horas = await prisma.horas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HorasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HorasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Horas.
     * @param {HorasUpsertArgs} args - Arguments to update or create a Horas.
     * @example
     * // Update or create a Horas
     * const horas = await prisma.horas.upsert({
     *   create: {
     *     // ... data to create a Horas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Horas we want to update
     *   }
     * })
    **/
    upsert<T extends HorasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HorasUpsertArgs<ExtArgs>>
    ): Prisma__HorasClient<$Result.GetResult<Prisma.$HorasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Horas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasCountArgs} args - Arguments to filter Horas to count.
     * @example
     * // Count the number of Horas
     * const count = await prisma.horas.count({
     *   where: {
     *     // ... the filter for the Horas we want to count
     *   }
     * })
    **/
    count<T extends HorasCountArgs>(
      args?: Subset<T, HorasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HorasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Horas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HorasAggregateArgs>(args: Subset<T, HorasAggregateArgs>): Prisma.PrismaPromise<GetHorasAggregateType<T>>

    /**
     * Group by Horas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HorasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HorasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HorasGroupByArgs['orderBy'] }
        : { orderBy?: HorasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HorasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHorasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Horas model
   */
  readonly fields: HorasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Horas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HorasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    aluno<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Horas model
   */ 
  interface HorasFieldRefs {
    readonly id: FieldRef<"Horas", 'Int'>
    readonly horasAnuais: FieldRef<"Horas", 'Int'>
    readonly horasConcluidas: FieldRef<"Horas", 'Int'>
    readonly ano: FieldRef<"Horas", 'Int'>
    readonly codAluno: FieldRef<"Horas", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Horas findUnique
   */
  export type HorasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * Filter, which Horas to fetch.
     */
    where: HorasWhereUniqueInput
  }


  /**
   * Horas findUniqueOrThrow
   */
  export type HorasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * Filter, which Horas to fetch.
     */
    where: HorasWhereUniqueInput
  }


  /**
   * Horas findFirst
   */
  export type HorasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * Filter, which Horas to fetch.
     */
    where?: HorasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horas to fetch.
     */
    orderBy?: HorasOrderByWithRelationInput | HorasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Horas.
     */
    cursor?: HorasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Horas.
     */
    distinct?: HorasScalarFieldEnum | HorasScalarFieldEnum[]
  }


  /**
   * Horas findFirstOrThrow
   */
  export type HorasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * Filter, which Horas to fetch.
     */
    where?: HorasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horas to fetch.
     */
    orderBy?: HorasOrderByWithRelationInput | HorasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Horas.
     */
    cursor?: HorasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Horas.
     */
    distinct?: HorasScalarFieldEnum | HorasScalarFieldEnum[]
  }


  /**
   * Horas findMany
   */
  export type HorasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * Filter, which Horas to fetch.
     */
    where?: HorasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Horas to fetch.
     */
    orderBy?: HorasOrderByWithRelationInput | HorasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Horas.
     */
    cursor?: HorasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Horas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Horas.
     */
    skip?: number
    distinct?: HorasScalarFieldEnum | HorasScalarFieldEnum[]
  }


  /**
   * Horas create
   */
  export type HorasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * The data needed to create a Horas.
     */
    data: XOR<HorasCreateInput, HorasUncheckedCreateInput>
  }


  /**
   * Horas createMany
   */
  export type HorasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Horas.
     */
    data: HorasCreateManyInput | HorasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Horas update
   */
  export type HorasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * The data needed to update a Horas.
     */
    data: XOR<HorasUpdateInput, HorasUncheckedUpdateInput>
    /**
     * Choose, which Horas to update.
     */
    where: HorasWhereUniqueInput
  }


  /**
   * Horas updateMany
   */
  export type HorasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Horas.
     */
    data: XOR<HorasUpdateManyMutationInput, HorasUncheckedUpdateManyInput>
    /**
     * Filter which Horas to update
     */
    where?: HorasWhereInput
  }


  /**
   * Horas upsert
   */
  export type HorasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * The filter to search for the Horas to update in case it exists.
     */
    where: HorasWhereUniqueInput
    /**
     * In case the Horas found by the `where` argument doesn't exist, create a new Horas with this data.
     */
    create: XOR<HorasCreateInput, HorasUncheckedCreateInput>
    /**
     * In case the Horas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HorasUpdateInput, HorasUncheckedUpdateInput>
  }


  /**
   * Horas delete
   */
  export type HorasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
    /**
     * Filter which Horas to delete.
     */
    where: HorasWhereUniqueInput
  }


  /**
   * Horas deleteMany
   */
  export type HorasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Horas to delete
     */
    where?: HorasWhereInput
  }


  /**
   * Horas without action
   */
  export type HorasDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Horas
     */
    select?: HorasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HorasInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EscolaScalarFieldEnum: {
    id: 'id',
    nomeEscola: 'nomeEscola'
  };

  export type EscolaScalarFieldEnum = (typeof EscolaScalarFieldEnum)[keyof typeof EscolaScalarFieldEnum]


  export const TurmaScalarFieldEnum: {
    id: 'id',
    ano: 'ano',
    nomeTurma: 'nomeTurma',
    codEscola: 'codEscola'
  };

  export type TurmaScalarFieldEnum = (typeof TurmaScalarFieldEnum)[keyof typeof TurmaScalarFieldEnum]


  export const TipoUsuarioScalarFieldEnum: {
    id: 'id',
    tipoUsuario: 'tipoUsuario'
  };

  export type TipoUsuarioScalarFieldEnum = (typeof TipoUsuarioScalarFieldEnum)[keyof typeof TipoUsuarioScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    email: 'email',
    senha: 'senha',
    nome: 'nome',
    rm: 'rm',
    codEscola: 'codEscola',
    codTipoUsuario: 'codTipoUsuario',
    codTurma: 'codTurma'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const AtividadeScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descricao: 'descricao',
    anexos: 'anexos',
    horasAtividade: 'horasAtividade',
    dataCriacao: 'dataCriacao',
    prazoEntrega: 'prazoEntrega',
    codTipoAtividade: 'codTipoAtividade'
  };

  export type AtividadeScalarFieldEnum = (typeof AtividadeScalarFieldEnum)[keyof typeof AtividadeScalarFieldEnum]


  export const TipoAtividadeScalarFieldEnum: {
    id: 'id',
    tipoAtividade: 'tipoAtividade'
  };

  export type TipoAtividadeScalarFieldEnum = (typeof TipoAtividadeScalarFieldEnum)[keyof typeof TipoAtividadeScalarFieldEnum]


  export const EntregaScalarFieldEnum: {
    id: 'id',
    dataEntrega: 'dataEntrega',
    conteudo: 'conteudo',
    entregue: 'entregue',
    codAluno: 'codAluno',
    codAtividade: 'codAtividade'
  };

  export type EntregaScalarFieldEnum = (typeof EntregaScalarFieldEnum)[keyof typeof EntregaScalarFieldEnum]


  export const SolicitacaoSuporteScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    conteudo: 'conteudo',
    dataCriacao: 'dataCriacao',
    codAluno: 'codAluno'
  };

  export type SolicitacaoSuporteScalarFieldEnum = (typeof SolicitacaoSuporteScalarFieldEnum)[keyof typeof SolicitacaoSuporteScalarFieldEnum]


  export const RespostaScalarFieldEnum: {
    id: 'id',
    dataResposta: 'dataResposta',
    resposta: 'resposta',
    codCoordenador: 'codCoordenador',
    codSolicitacao: 'codSolicitacao'
  };

  export type RespostaScalarFieldEnum = (typeof RespostaScalarFieldEnum)[keyof typeof RespostaScalarFieldEnum]


  export const CorrecaoScalarFieldEnum: {
    id: 'id',
    dataCorrecao: 'dataCorrecao',
    conteudo: 'conteudo',
    codCoordenador: 'codCoordenador',
    codEntrega: 'codEntrega'
  };

  export type CorrecaoScalarFieldEnum = (typeof CorrecaoScalarFieldEnum)[keyof typeof CorrecaoScalarFieldEnum]


  export const HorasScalarFieldEnum: {
    id: 'id',
    horasAnuais: 'horasAnuais',
    horasConcluidas: 'horasConcluidas',
    ano: 'ano',
    codAluno: 'codAluno'
  };

  export type HorasScalarFieldEnum = (typeof HorasScalarFieldEnum)[keyof typeof HorasScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type EscolaWhereInput = {
    AND?: EscolaWhereInput | EscolaWhereInput[]
    OR?: EscolaWhereInput[]
    NOT?: EscolaWhereInput | EscolaWhereInput[]
    id?: IntFilter<"Escola"> | number
    nomeEscola?: StringFilter<"Escola"> | string
    Usuario?: UsuarioListRelationFilter
    Turma?: TurmaListRelationFilter
  }

  export type EscolaOrderByWithRelationInput = {
    id?: SortOrder
    nomeEscola?: SortOrder
    Usuario?: UsuarioOrderByRelationAggregateInput
    Turma?: TurmaOrderByRelationAggregateInput
  }

  export type EscolaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EscolaWhereInput | EscolaWhereInput[]
    OR?: EscolaWhereInput[]
    NOT?: EscolaWhereInput | EscolaWhereInput[]
    nomeEscola?: StringFilter<"Escola"> | string
    Usuario?: UsuarioListRelationFilter
    Turma?: TurmaListRelationFilter
  }, "id">

  export type EscolaOrderByWithAggregationInput = {
    id?: SortOrder
    nomeEscola?: SortOrder
    _count?: EscolaCountOrderByAggregateInput
    _avg?: EscolaAvgOrderByAggregateInput
    _max?: EscolaMaxOrderByAggregateInput
    _min?: EscolaMinOrderByAggregateInput
    _sum?: EscolaSumOrderByAggregateInput
  }

  export type EscolaScalarWhereWithAggregatesInput = {
    AND?: EscolaScalarWhereWithAggregatesInput | EscolaScalarWhereWithAggregatesInput[]
    OR?: EscolaScalarWhereWithAggregatesInput[]
    NOT?: EscolaScalarWhereWithAggregatesInput | EscolaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Escola"> | number
    nomeEscola?: StringWithAggregatesFilter<"Escola"> | string
  }

  export type TurmaWhereInput = {
    AND?: TurmaWhereInput | TurmaWhereInput[]
    OR?: TurmaWhereInput[]
    NOT?: TurmaWhereInput | TurmaWhereInput[]
    id?: IntFilter<"Turma"> | number
    ano?: IntFilter<"Turma"> | number
    nomeTurma?: StringFilter<"Turma"> | string
    codEscola?: IntFilter<"Turma"> | number
    escola?: XOR<EscolaRelationFilter, EscolaWhereInput>
    Usuario?: UsuarioListRelationFilter
  }

  export type TurmaOrderByWithRelationInput = {
    id?: SortOrder
    ano?: SortOrder
    nomeTurma?: SortOrder
    codEscola?: SortOrder
    escola?: EscolaOrderByWithRelationInput
    Usuario?: UsuarioOrderByRelationAggregateInput
  }

  export type TurmaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TurmaWhereInput | TurmaWhereInput[]
    OR?: TurmaWhereInput[]
    NOT?: TurmaWhereInput | TurmaWhereInput[]
    ano?: IntFilter<"Turma"> | number
    nomeTurma?: StringFilter<"Turma"> | string
    codEscola?: IntFilter<"Turma"> | number
    escola?: XOR<EscolaRelationFilter, EscolaWhereInput>
    Usuario?: UsuarioListRelationFilter
  }, "id">

  export type TurmaOrderByWithAggregationInput = {
    id?: SortOrder
    ano?: SortOrder
    nomeTurma?: SortOrder
    codEscola?: SortOrder
    _count?: TurmaCountOrderByAggregateInput
    _avg?: TurmaAvgOrderByAggregateInput
    _max?: TurmaMaxOrderByAggregateInput
    _min?: TurmaMinOrderByAggregateInput
    _sum?: TurmaSumOrderByAggregateInput
  }

  export type TurmaScalarWhereWithAggregatesInput = {
    AND?: TurmaScalarWhereWithAggregatesInput | TurmaScalarWhereWithAggregatesInput[]
    OR?: TurmaScalarWhereWithAggregatesInput[]
    NOT?: TurmaScalarWhereWithAggregatesInput | TurmaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Turma"> | number
    ano?: IntWithAggregatesFilter<"Turma"> | number
    nomeTurma?: StringWithAggregatesFilter<"Turma"> | string
    codEscola?: IntWithAggregatesFilter<"Turma"> | number
  }

  export type tipoUsuarioWhereInput = {
    AND?: tipoUsuarioWhereInput | tipoUsuarioWhereInput[]
    OR?: tipoUsuarioWhereInput[]
    NOT?: tipoUsuarioWhereInput | tipoUsuarioWhereInput[]
    id?: IntFilter<"tipoUsuario"> | number
    tipoUsuario?: StringFilter<"tipoUsuario"> | string
    Usuario?: UsuarioListRelationFilter
  }

  export type tipoUsuarioOrderByWithRelationInput = {
    id?: SortOrder
    tipoUsuario?: SortOrder
    Usuario?: UsuarioOrderByRelationAggregateInput
  }

  export type tipoUsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tipoUsuarioWhereInput | tipoUsuarioWhereInput[]
    OR?: tipoUsuarioWhereInput[]
    NOT?: tipoUsuarioWhereInput | tipoUsuarioWhereInput[]
    tipoUsuario?: StringFilter<"tipoUsuario"> | string
    Usuario?: UsuarioListRelationFilter
  }, "id">

  export type tipoUsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    tipoUsuario?: SortOrder
    _count?: tipoUsuarioCountOrderByAggregateInput
    _avg?: tipoUsuarioAvgOrderByAggregateInput
    _max?: tipoUsuarioMaxOrderByAggregateInput
    _min?: tipoUsuarioMinOrderByAggregateInput
    _sum?: tipoUsuarioSumOrderByAggregateInput
  }

  export type tipoUsuarioScalarWhereWithAggregatesInput = {
    AND?: tipoUsuarioScalarWhereWithAggregatesInput | tipoUsuarioScalarWhereWithAggregatesInput[]
    OR?: tipoUsuarioScalarWhereWithAggregatesInput[]
    NOT?: tipoUsuarioScalarWhereWithAggregatesInput | tipoUsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipoUsuario"> | number
    tipoUsuario?: StringWithAggregatesFilter<"tipoUsuario"> | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    rm?: IntNullableFilter<"Usuario"> | number | null
    codEscola?: IntNullableFilter<"Usuario"> | number | null
    codTipoUsuario?: IntFilter<"Usuario"> | number
    codTurma?: IntNullableFilter<"Usuario"> | number | null
    escolaRel?: XOR<EscolaNullableRelationFilter, EscolaWhereInput> | null
    tipoUsuario?: XOR<TipoUsuarioRelationFilter, tipoUsuarioWhereInput>
    turma?: XOR<TurmaNullableRelationFilter, TurmaWhereInput> | null
    Entrega?: EntregaListRelationFilter
    SolicitacaoSuporte?: SolicitacaoSuporteListRelationFilter
    Resposta?: RespostaListRelationFilter
    Correcao?: CorrecaoListRelationFilter
    Horas?: HorasListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nome?: SortOrder
    rm?: SortOrderInput | SortOrder
    codEscola?: SortOrderInput | SortOrder
    codTipoUsuario?: SortOrder
    codTurma?: SortOrderInput | SortOrder
    escolaRel?: EscolaOrderByWithRelationInput
    tipoUsuario?: tipoUsuarioOrderByWithRelationInput
    turma?: TurmaOrderByWithRelationInput
    Entrega?: EntregaOrderByRelationAggregateInput
    SolicitacaoSuporte?: SolicitacaoSuporteOrderByRelationAggregateInput
    Resposta?: RespostaOrderByRelationAggregateInput
    Correcao?: CorrecaoOrderByRelationAggregateInput
    Horas?: HorasOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    rm?: number
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    senha?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    codEscola?: IntNullableFilter<"Usuario"> | number | null
    codTipoUsuario?: IntFilter<"Usuario"> | number
    codTurma?: IntNullableFilter<"Usuario"> | number | null
    escolaRel?: XOR<EscolaNullableRelationFilter, EscolaWhereInput> | null
    tipoUsuario?: XOR<TipoUsuarioRelationFilter, tipoUsuarioWhereInput>
    turma?: XOR<TurmaNullableRelationFilter, TurmaWhereInput> | null
    Entrega?: EntregaListRelationFilter
    SolicitacaoSuporte?: SolicitacaoSuporteListRelationFilter
    Resposta?: RespostaListRelationFilter
    Correcao?: CorrecaoListRelationFilter
    Horas?: HorasListRelationFilter
  }, "id" | "email" | "rm">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nome?: SortOrder
    rm?: SortOrderInput | SortOrder
    codEscola?: SortOrderInput | SortOrder
    codTipoUsuario?: SortOrder
    codTurma?: SortOrderInput | SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    rm?: IntNullableWithAggregatesFilter<"Usuario"> | number | null
    codEscola?: IntNullableWithAggregatesFilter<"Usuario"> | number | null
    codTipoUsuario?: IntWithAggregatesFilter<"Usuario"> | number
    codTurma?: IntNullableWithAggregatesFilter<"Usuario"> | number | null
  }

  export type AtividadeWhereInput = {
    AND?: AtividadeWhereInput | AtividadeWhereInput[]
    OR?: AtividadeWhereInput[]
    NOT?: AtividadeWhereInput | AtividadeWhereInput[]
    id?: IntFilter<"Atividade"> | number
    titulo?: StringFilter<"Atividade"> | string
    descricao?: StringFilter<"Atividade"> | string
    anexos?: StringNullableFilter<"Atividade"> | string | null
    horasAtividade?: IntFilter<"Atividade"> | number
    dataCriacao?: DateTimeFilter<"Atividade"> | Date | string
    prazoEntrega?: DateTimeFilter<"Atividade"> | Date | string
    codTipoAtividade?: IntFilter<"Atividade"> | number
    tipoAtividade?: XOR<TipoAtividadeRelationFilter, tipoAtividadeWhereInput>
    entrega?: EntregaListRelationFilter
  }

  export type AtividadeOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    anexos?: SortOrderInput | SortOrder
    horasAtividade?: SortOrder
    dataCriacao?: SortOrder
    prazoEntrega?: SortOrder
    codTipoAtividade?: SortOrder
    tipoAtividade?: tipoAtividadeOrderByWithRelationInput
    entrega?: EntregaOrderByRelationAggregateInput
  }

  export type AtividadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AtividadeWhereInput | AtividadeWhereInput[]
    OR?: AtividadeWhereInput[]
    NOT?: AtividadeWhereInput | AtividadeWhereInput[]
    titulo?: StringFilter<"Atividade"> | string
    descricao?: StringFilter<"Atividade"> | string
    anexos?: StringNullableFilter<"Atividade"> | string | null
    horasAtividade?: IntFilter<"Atividade"> | number
    dataCriacao?: DateTimeFilter<"Atividade"> | Date | string
    prazoEntrega?: DateTimeFilter<"Atividade"> | Date | string
    codTipoAtividade?: IntFilter<"Atividade"> | number
    tipoAtividade?: XOR<TipoAtividadeRelationFilter, tipoAtividadeWhereInput>
    entrega?: EntregaListRelationFilter
  }, "id">

  export type AtividadeOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    anexos?: SortOrderInput | SortOrder
    horasAtividade?: SortOrder
    dataCriacao?: SortOrder
    prazoEntrega?: SortOrder
    codTipoAtividade?: SortOrder
    _count?: AtividadeCountOrderByAggregateInput
    _avg?: AtividadeAvgOrderByAggregateInput
    _max?: AtividadeMaxOrderByAggregateInput
    _min?: AtividadeMinOrderByAggregateInput
    _sum?: AtividadeSumOrderByAggregateInput
  }

  export type AtividadeScalarWhereWithAggregatesInput = {
    AND?: AtividadeScalarWhereWithAggregatesInput | AtividadeScalarWhereWithAggregatesInput[]
    OR?: AtividadeScalarWhereWithAggregatesInput[]
    NOT?: AtividadeScalarWhereWithAggregatesInput | AtividadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Atividade"> | number
    titulo?: StringWithAggregatesFilter<"Atividade"> | string
    descricao?: StringWithAggregatesFilter<"Atividade"> | string
    anexos?: StringNullableWithAggregatesFilter<"Atividade"> | string | null
    horasAtividade?: IntWithAggregatesFilter<"Atividade"> | number
    dataCriacao?: DateTimeWithAggregatesFilter<"Atividade"> | Date | string
    prazoEntrega?: DateTimeWithAggregatesFilter<"Atividade"> | Date | string
    codTipoAtividade?: IntWithAggregatesFilter<"Atividade"> | number
  }

  export type tipoAtividadeWhereInput = {
    AND?: tipoAtividadeWhereInput | tipoAtividadeWhereInput[]
    OR?: tipoAtividadeWhereInput[]
    NOT?: tipoAtividadeWhereInput | tipoAtividadeWhereInput[]
    id?: IntFilter<"tipoAtividade"> | number
    tipoAtividade?: StringFilter<"tipoAtividade"> | string
    Atividade?: AtividadeListRelationFilter
  }

  export type tipoAtividadeOrderByWithRelationInput = {
    id?: SortOrder
    tipoAtividade?: SortOrder
    Atividade?: AtividadeOrderByRelationAggregateInput
  }

  export type tipoAtividadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tipoAtividadeWhereInput | tipoAtividadeWhereInput[]
    OR?: tipoAtividadeWhereInput[]
    NOT?: tipoAtividadeWhereInput | tipoAtividadeWhereInput[]
    tipoAtividade?: StringFilter<"tipoAtividade"> | string
    Atividade?: AtividadeListRelationFilter
  }, "id">

  export type tipoAtividadeOrderByWithAggregationInput = {
    id?: SortOrder
    tipoAtividade?: SortOrder
    _count?: tipoAtividadeCountOrderByAggregateInput
    _avg?: tipoAtividadeAvgOrderByAggregateInput
    _max?: tipoAtividadeMaxOrderByAggregateInput
    _min?: tipoAtividadeMinOrderByAggregateInput
    _sum?: tipoAtividadeSumOrderByAggregateInput
  }

  export type tipoAtividadeScalarWhereWithAggregatesInput = {
    AND?: tipoAtividadeScalarWhereWithAggregatesInput | tipoAtividadeScalarWhereWithAggregatesInput[]
    OR?: tipoAtividadeScalarWhereWithAggregatesInput[]
    NOT?: tipoAtividadeScalarWhereWithAggregatesInput | tipoAtividadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipoAtividade"> | number
    tipoAtividade?: StringWithAggregatesFilter<"tipoAtividade"> | string
  }

  export type EntregaWhereInput = {
    AND?: EntregaWhereInput | EntregaWhereInput[]
    OR?: EntregaWhereInput[]
    NOT?: EntregaWhereInput | EntregaWhereInput[]
    id?: IntFilter<"Entrega"> | number
    dataEntrega?: DateTimeNullableFilter<"Entrega"> | Date | string | null
    conteudo?: StringNullableFilter<"Entrega"> | string | null
    entregue?: BoolFilter<"Entrega"> | boolean
    codAluno?: IntFilter<"Entrega"> | number
    codAtividade?: IntFilter<"Entrega"> | number
    aluno?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    atividade?: XOR<AtividadeRelationFilter, AtividadeWhereInput>
    Correcao?: XOR<CorrecaoNullableRelationFilter, CorrecaoWhereInput> | null
  }

  export type EntregaOrderByWithRelationInput = {
    id?: SortOrder
    dataEntrega?: SortOrderInput | SortOrder
    conteudo?: SortOrderInput | SortOrder
    entregue?: SortOrder
    codAluno?: SortOrder
    codAtividade?: SortOrder
    aluno?: UsuarioOrderByWithRelationInput
    atividade?: AtividadeOrderByWithRelationInput
    Correcao?: CorrecaoOrderByWithRelationInput
  }

  export type EntregaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntregaWhereInput | EntregaWhereInput[]
    OR?: EntregaWhereInput[]
    NOT?: EntregaWhereInput | EntregaWhereInput[]
    dataEntrega?: DateTimeNullableFilter<"Entrega"> | Date | string | null
    conteudo?: StringNullableFilter<"Entrega"> | string | null
    entregue?: BoolFilter<"Entrega"> | boolean
    codAluno?: IntFilter<"Entrega"> | number
    codAtividade?: IntFilter<"Entrega"> | number
    aluno?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    atividade?: XOR<AtividadeRelationFilter, AtividadeWhereInput>
    Correcao?: XOR<CorrecaoNullableRelationFilter, CorrecaoWhereInput> | null
  }, "id">

  export type EntregaOrderByWithAggregationInput = {
    id?: SortOrder
    dataEntrega?: SortOrderInput | SortOrder
    conteudo?: SortOrderInput | SortOrder
    entregue?: SortOrder
    codAluno?: SortOrder
    codAtividade?: SortOrder
    _count?: EntregaCountOrderByAggregateInput
    _avg?: EntregaAvgOrderByAggregateInput
    _max?: EntregaMaxOrderByAggregateInput
    _min?: EntregaMinOrderByAggregateInput
    _sum?: EntregaSumOrderByAggregateInput
  }

  export type EntregaScalarWhereWithAggregatesInput = {
    AND?: EntregaScalarWhereWithAggregatesInput | EntregaScalarWhereWithAggregatesInput[]
    OR?: EntregaScalarWhereWithAggregatesInput[]
    NOT?: EntregaScalarWhereWithAggregatesInput | EntregaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entrega"> | number
    dataEntrega?: DateTimeNullableWithAggregatesFilter<"Entrega"> | Date | string | null
    conteudo?: StringNullableWithAggregatesFilter<"Entrega"> | string | null
    entregue?: BoolWithAggregatesFilter<"Entrega"> | boolean
    codAluno?: IntWithAggregatesFilter<"Entrega"> | number
    codAtividade?: IntWithAggregatesFilter<"Entrega"> | number
  }

  export type SolicitacaoSuporteWhereInput = {
    AND?: SolicitacaoSuporteWhereInput | SolicitacaoSuporteWhereInput[]
    OR?: SolicitacaoSuporteWhereInput[]
    NOT?: SolicitacaoSuporteWhereInput | SolicitacaoSuporteWhereInput[]
    id?: IntFilter<"SolicitacaoSuporte"> | number
    titulo?: StringFilter<"SolicitacaoSuporte"> | string
    conteudo?: StringFilter<"SolicitacaoSuporte"> | string
    dataCriacao?: DateTimeFilter<"SolicitacaoSuporte"> | Date | string
    codAluno?: IntFilter<"SolicitacaoSuporte"> | number
    aluno?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    Resposta?: XOR<RespostaNullableRelationFilter, RespostaWhereInput> | null
  }

  export type SolicitacaoSuporteOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    dataCriacao?: SortOrder
    codAluno?: SortOrder
    aluno?: UsuarioOrderByWithRelationInput
    Resposta?: RespostaOrderByWithRelationInput
  }

  export type SolicitacaoSuporteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SolicitacaoSuporteWhereInput | SolicitacaoSuporteWhereInput[]
    OR?: SolicitacaoSuporteWhereInput[]
    NOT?: SolicitacaoSuporteWhereInput | SolicitacaoSuporteWhereInput[]
    titulo?: StringFilter<"SolicitacaoSuporte"> | string
    conteudo?: StringFilter<"SolicitacaoSuporte"> | string
    dataCriacao?: DateTimeFilter<"SolicitacaoSuporte"> | Date | string
    codAluno?: IntFilter<"SolicitacaoSuporte"> | number
    aluno?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    Resposta?: XOR<RespostaNullableRelationFilter, RespostaWhereInput> | null
  }, "id">

  export type SolicitacaoSuporteOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    dataCriacao?: SortOrder
    codAluno?: SortOrder
    _count?: SolicitacaoSuporteCountOrderByAggregateInput
    _avg?: SolicitacaoSuporteAvgOrderByAggregateInput
    _max?: SolicitacaoSuporteMaxOrderByAggregateInput
    _min?: SolicitacaoSuporteMinOrderByAggregateInput
    _sum?: SolicitacaoSuporteSumOrderByAggregateInput
  }

  export type SolicitacaoSuporteScalarWhereWithAggregatesInput = {
    AND?: SolicitacaoSuporteScalarWhereWithAggregatesInput | SolicitacaoSuporteScalarWhereWithAggregatesInput[]
    OR?: SolicitacaoSuporteScalarWhereWithAggregatesInput[]
    NOT?: SolicitacaoSuporteScalarWhereWithAggregatesInput | SolicitacaoSuporteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SolicitacaoSuporte"> | number
    titulo?: StringWithAggregatesFilter<"SolicitacaoSuporte"> | string
    conteudo?: StringWithAggregatesFilter<"SolicitacaoSuporte"> | string
    dataCriacao?: DateTimeWithAggregatesFilter<"SolicitacaoSuporte"> | Date | string
    codAluno?: IntWithAggregatesFilter<"SolicitacaoSuporte"> | number
  }

  export type RespostaWhereInput = {
    AND?: RespostaWhereInput | RespostaWhereInput[]
    OR?: RespostaWhereInput[]
    NOT?: RespostaWhereInput | RespostaWhereInput[]
    id?: IntFilter<"Resposta"> | number
    dataResposta?: DateTimeFilter<"Resposta"> | Date | string
    resposta?: StringFilter<"Resposta"> | string
    codCoordenador?: IntFilter<"Resposta"> | number
    codSolicitacao?: IntFilter<"Resposta"> | number
    coordenador?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    solicitacaoSuporte?: XOR<SolicitacaoSuporteRelationFilter, SolicitacaoSuporteWhereInput>
  }

  export type RespostaOrderByWithRelationInput = {
    id?: SortOrder
    dataResposta?: SortOrder
    resposta?: SortOrder
    codCoordenador?: SortOrder
    codSolicitacao?: SortOrder
    coordenador?: UsuarioOrderByWithRelationInput
    solicitacaoSuporte?: SolicitacaoSuporteOrderByWithRelationInput
  }

  export type RespostaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codSolicitacao?: number
    AND?: RespostaWhereInput | RespostaWhereInput[]
    OR?: RespostaWhereInput[]
    NOT?: RespostaWhereInput | RespostaWhereInput[]
    dataResposta?: DateTimeFilter<"Resposta"> | Date | string
    resposta?: StringFilter<"Resposta"> | string
    codCoordenador?: IntFilter<"Resposta"> | number
    coordenador?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    solicitacaoSuporte?: XOR<SolicitacaoSuporteRelationFilter, SolicitacaoSuporteWhereInput>
  }, "id" | "codSolicitacao">

  export type RespostaOrderByWithAggregationInput = {
    id?: SortOrder
    dataResposta?: SortOrder
    resposta?: SortOrder
    codCoordenador?: SortOrder
    codSolicitacao?: SortOrder
    _count?: RespostaCountOrderByAggregateInput
    _avg?: RespostaAvgOrderByAggregateInput
    _max?: RespostaMaxOrderByAggregateInput
    _min?: RespostaMinOrderByAggregateInput
    _sum?: RespostaSumOrderByAggregateInput
  }

  export type RespostaScalarWhereWithAggregatesInput = {
    AND?: RespostaScalarWhereWithAggregatesInput | RespostaScalarWhereWithAggregatesInput[]
    OR?: RespostaScalarWhereWithAggregatesInput[]
    NOT?: RespostaScalarWhereWithAggregatesInput | RespostaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resposta"> | number
    dataResposta?: DateTimeWithAggregatesFilter<"Resposta"> | Date | string
    resposta?: StringWithAggregatesFilter<"Resposta"> | string
    codCoordenador?: IntWithAggregatesFilter<"Resposta"> | number
    codSolicitacao?: IntWithAggregatesFilter<"Resposta"> | number
  }

  export type CorrecaoWhereInput = {
    AND?: CorrecaoWhereInput | CorrecaoWhereInput[]
    OR?: CorrecaoWhereInput[]
    NOT?: CorrecaoWhereInput | CorrecaoWhereInput[]
    id?: IntFilter<"Correcao"> | number
    dataCorrecao?: DateTimeFilter<"Correcao"> | Date | string
    conteudo?: StringFilter<"Correcao"> | string
    codCoordenador?: IntFilter<"Correcao"> | number
    codEntrega?: IntFilter<"Correcao"> | number
    coordenador?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    entrega?: XOR<EntregaRelationFilter, EntregaWhereInput>
  }

  export type CorrecaoOrderByWithRelationInput = {
    id?: SortOrder
    dataCorrecao?: SortOrder
    conteudo?: SortOrder
    codCoordenador?: SortOrder
    codEntrega?: SortOrder
    coordenador?: UsuarioOrderByWithRelationInput
    entrega?: EntregaOrderByWithRelationInput
  }

  export type CorrecaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codEntrega?: number
    AND?: CorrecaoWhereInput | CorrecaoWhereInput[]
    OR?: CorrecaoWhereInput[]
    NOT?: CorrecaoWhereInput | CorrecaoWhereInput[]
    dataCorrecao?: DateTimeFilter<"Correcao"> | Date | string
    conteudo?: StringFilter<"Correcao"> | string
    codCoordenador?: IntFilter<"Correcao"> | number
    coordenador?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    entrega?: XOR<EntregaRelationFilter, EntregaWhereInput>
  }, "id" | "codEntrega">

  export type CorrecaoOrderByWithAggregationInput = {
    id?: SortOrder
    dataCorrecao?: SortOrder
    conteudo?: SortOrder
    codCoordenador?: SortOrder
    codEntrega?: SortOrder
    _count?: CorrecaoCountOrderByAggregateInput
    _avg?: CorrecaoAvgOrderByAggregateInput
    _max?: CorrecaoMaxOrderByAggregateInput
    _min?: CorrecaoMinOrderByAggregateInput
    _sum?: CorrecaoSumOrderByAggregateInput
  }

  export type CorrecaoScalarWhereWithAggregatesInput = {
    AND?: CorrecaoScalarWhereWithAggregatesInput | CorrecaoScalarWhereWithAggregatesInput[]
    OR?: CorrecaoScalarWhereWithAggregatesInput[]
    NOT?: CorrecaoScalarWhereWithAggregatesInput | CorrecaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Correcao"> | number
    dataCorrecao?: DateTimeWithAggregatesFilter<"Correcao"> | Date | string
    conteudo?: StringWithAggregatesFilter<"Correcao"> | string
    codCoordenador?: IntWithAggregatesFilter<"Correcao"> | number
    codEntrega?: IntWithAggregatesFilter<"Correcao"> | number
  }

  export type HorasWhereInput = {
    AND?: HorasWhereInput | HorasWhereInput[]
    OR?: HorasWhereInput[]
    NOT?: HorasWhereInput | HorasWhereInput[]
    id?: IntFilter<"Horas"> | number
    horasAnuais?: IntFilter<"Horas"> | number
    horasConcluidas?: IntFilter<"Horas"> | number
    ano?: IntFilter<"Horas"> | number
    codAluno?: IntFilter<"Horas"> | number
    aluno?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type HorasOrderByWithRelationInput = {
    id?: SortOrder
    horasAnuais?: SortOrder
    horasConcluidas?: SortOrder
    ano?: SortOrder
    codAluno?: SortOrder
    aluno?: UsuarioOrderByWithRelationInput
  }

  export type HorasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HorasWhereInput | HorasWhereInput[]
    OR?: HorasWhereInput[]
    NOT?: HorasWhereInput | HorasWhereInput[]
    horasAnuais?: IntFilter<"Horas"> | number
    horasConcluidas?: IntFilter<"Horas"> | number
    ano?: IntFilter<"Horas"> | number
    codAluno?: IntFilter<"Horas"> | number
    aluno?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type HorasOrderByWithAggregationInput = {
    id?: SortOrder
    horasAnuais?: SortOrder
    horasConcluidas?: SortOrder
    ano?: SortOrder
    codAluno?: SortOrder
    _count?: HorasCountOrderByAggregateInput
    _avg?: HorasAvgOrderByAggregateInput
    _max?: HorasMaxOrderByAggregateInput
    _min?: HorasMinOrderByAggregateInput
    _sum?: HorasSumOrderByAggregateInput
  }

  export type HorasScalarWhereWithAggregatesInput = {
    AND?: HorasScalarWhereWithAggregatesInput | HorasScalarWhereWithAggregatesInput[]
    OR?: HorasScalarWhereWithAggregatesInput[]
    NOT?: HorasScalarWhereWithAggregatesInput | HorasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Horas"> | number
    horasAnuais?: IntWithAggregatesFilter<"Horas"> | number
    horasConcluidas?: IntWithAggregatesFilter<"Horas"> | number
    ano?: IntWithAggregatesFilter<"Horas"> | number
    codAluno?: IntWithAggregatesFilter<"Horas"> | number
  }

  export type EscolaCreateInput = {
    nomeEscola: string
    Usuario?: UsuarioCreateNestedManyWithoutEscolaRelInput
    Turma?: TurmaCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUncheckedCreateInput = {
    id?: number
    nomeEscola: string
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutEscolaRelInput
    Turma?: TurmaUncheckedCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUpdateInput = {
    nomeEscola?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateManyWithoutEscolaRelNestedInput
    Turma?: TurmaUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUncheckedUpdateManyWithoutEscolaRelNestedInput
    Turma?: TurmaUncheckedUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaCreateManyInput = {
    id?: number
    nomeEscola: string
  }

  export type EscolaUpdateManyMutationInput = {
    nomeEscola?: StringFieldUpdateOperationsInput | string
  }

  export type EscolaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
  }

  export type TurmaCreateInput = {
    ano: number
    nomeTurma: string
    escola: EscolaCreateNestedOneWithoutTurmaInput
    Usuario?: UsuarioCreateNestedManyWithoutTurmaInput
  }

  export type TurmaUncheckedCreateInput = {
    id?: number
    ano: number
    nomeTurma: string
    codEscola: number
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type TurmaUpdateInput = {
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
    escola?: EscolaUpdateOneRequiredWithoutTurmaNestedInput
    Usuario?: UsuarioUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
    codEscola?: IntFieldUpdateOperationsInput | number
    Usuario?: UsuarioUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaCreateManyInput = {
    id?: number
    ano: number
    nomeTurma: string
    codEscola: number
  }

  export type TurmaUpdateManyMutationInput = {
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
  }

  export type TurmaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
    codEscola?: IntFieldUpdateOperationsInput | number
  }

  export type tipoUsuarioCreateInput = {
    tipoUsuario: string
    Usuario?: UsuarioCreateNestedManyWithoutTipoUsuarioInput
  }

  export type tipoUsuarioUncheckedCreateInput = {
    id?: number
    tipoUsuario: string
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutTipoUsuarioInput
  }

  export type tipoUsuarioUpdateInput = {
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateManyWithoutTipoUsuarioNestedInput
  }

  export type tipoUsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUncheckedUpdateManyWithoutTipoUsuarioNestedInput
  }

  export type tipoUsuarioCreateManyInput = {
    id?: number
    tipoUsuario: string
  }

  export type tipoUsuarioUpdateManyMutationInput = {
    tipoUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type tipoUsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    codTurma?: number | null
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    codTurma?: number | null
  }

  export type UsuarioUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AtividadeCreateInput = {
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
    tipoAtividade: tipoAtividadeCreateNestedOneWithoutAtividadeInput
    entrega?: EntregaCreateNestedManyWithoutAtividadeInput
  }

  export type AtividadeUncheckedCreateInput = {
    id?: number
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
    codTipoAtividade: number
    entrega?: EntregaUncheckedCreateNestedManyWithoutAtividadeInput
  }

  export type AtividadeUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoAtividade?: tipoAtividadeUpdateOneRequiredWithoutAtividadeNestedInput
    entrega?: EntregaUpdateManyWithoutAtividadeNestedInput
  }

  export type AtividadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    codTipoAtividade?: IntFieldUpdateOperationsInput | number
    entrega?: EntregaUncheckedUpdateManyWithoutAtividadeNestedInput
  }

  export type AtividadeCreateManyInput = {
    id?: number
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
    codTipoAtividade: number
  }

  export type AtividadeUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AtividadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    codTipoAtividade?: IntFieldUpdateOperationsInput | number
  }

  export type tipoAtividadeCreateInput = {
    tipoAtividade: string
    Atividade?: AtividadeCreateNestedManyWithoutTipoAtividadeInput
  }

  export type tipoAtividadeUncheckedCreateInput = {
    id?: number
    tipoAtividade: string
    Atividade?: AtividadeUncheckedCreateNestedManyWithoutTipoAtividadeInput
  }

  export type tipoAtividadeUpdateInput = {
    tipoAtividade?: StringFieldUpdateOperationsInput | string
    Atividade?: AtividadeUpdateManyWithoutTipoAtividadeNestedInput
  }

  export type tipoAtividadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAtividade?: StringFieldUpdateOperationsInput | string
    Atividade?: AtividadeUncheckedUpdateManyWithoutTipoAtividadeNestedInput
  }

  export type tipoAtividadeCreateManyInput = {
    id?: number
    tipoAtividade: string
  }

  export type tipoAtividadeUpdateManyMutationInput = {
    tipoAtividade?: StringFieldUpdateOperationsInput | string
  }

  export type tipoAtividadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAtividade?: StringFieldUpdateOperationsInput | string
  }

  export type EntregaCreateInput = {
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    aluno: UsuarioCreateNestedOneWithoutEntregaInput
    atividade: AtividadeCreateNestedOneWithoutEntregaInput
    Correcao?: CorrecaoCreateNestedOneWithoutEntregaInput
  }

  export type EntregaUncheckedCreateInput = {
    id?: number
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    codAluno: number
    codAtividade: number
    Correcao?: CorrecaoUncheckedCreateNestedOneWithoutEntregaInput
  }

  export type EntregaUpdateInput = {
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    aluno?: UsuarioUpdateOneRequiredWithoutEntregaNestedInput
    atividade?: AtividadeUpdateOneRequiredWithoutEntregaNestedInput
    Correcao?: CorrecaoUpdateOneWithoutEntregaNestedInput
  }

  export type EntregaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    codAluno?: IntFieldUpdateOperationsInput | number
    codAtividade?: IntFieldUpdateOperationsInput | number
    Correcao?: CorrecaoUncheckedUpdateOneWithoutEntregaNestedInput
  }

  export type EntregaCreateManyInput = {
    id?: number
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    codAluno: number
    codAtividade: number
  }

  export type EntregaUpdateManyMutationInput = {
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EntregaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    codAluno?: IntFieldUpdateOperationsInput | number
    codAtividade?: IntFieldUpdateOperationsInput | number
  }

  export type SolicitacaoSuporteCreateInput = {
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
    aluno: UsuarioCreateNestedOneWithoutSolicitacaoSuporteInput
    Resposta?: RespostaCreateNestedOneWithoutSolicitacaoSuporteInput
  }

  export type SolicitacaoSuporteUncheckedCreateInput = {
    id?: number
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
    codAluno: number
    Resposta?: RespostaUncheckedCreateNestedOneWithoutSolicitacaoSuporteInput
  }

  export type SolicitacaoSuporteUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    aluno?: UsuarioUpdateOneRequiredWithoutSolicitacaoSuporteNestedInput
    Resposta?: RespostaUpdateOneWithoutSolicitacaoSuporteNestedInput
  }

  export type SolicitacaoSuporteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    codAluno?: IntFieldUpdateOperationsInput | number
    Resposta?: RespostaUncheckedUpdateOneWithoutSolicitacaoSuporteNestedInput
  }

  export type SolicitacaoSuporteCreateManyInput = {
    id?: number
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
    codAluno: number
  }

  export type SolicitacaoSuporteUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SolicitacaoSuporteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    codAluno?: IntFieldUpdateOperationsInput | number
  }

  export type RespostaCreateInput = {
    dataResposta?: Date | string
    resposta: string
    coordenador: UsuarioCreateNestedOneWithoutRespostaInput
    solicitacaoSuporte: SolicitacaoSuporteCreateNestedOneWithoutRespostaInput
  }

  export type RespostaUncheckedCreateInput = {
    id?: number
    dataResposta?: Date | string
    resposta: string
    codCoordenador: number
    codSolicitacao: number
  }

  export type RespostaUpdateInput = {
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    coordenador?: UsuarioUpdateOneRequiredWithoutRespostaNestedInput
    solicitacaoSuporte?: SolicitacaoSuporteUpdateOneRequiredWithoutRespostaNestedInput
  }

  export type RespostaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    codCoordenador?: IntFieldUpdateOperationsInput | number
    codSolicitacao?: IntFieldUpdateOperationsInput | number
  }

  export type RespostaCreateManyInput = {
    id?: number
    dataResposta?: Date | string
    resposta: string
    codCoordenador: number
    codSolicitacao: number
  }

  export type RespostaUpdateManyMutationInput = {
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
  }

  export type RespostaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    codCoordenador?: IntFieldUpdateOperationsInput | number
    codSolicitacao?: IntFieldUpdateOperationsInput | number
  }

  export type CorrecaoCreateInput = {
    dataCorrecao?: Date | string
    conteudo: string
    coordenador: UsuarioCreateNestedOneWithoutCorrecaoInput
    entrega: EntregaCreateNestedOneWithoutCorrecaoInput
  }

  export type CorrecaoUncheckedCreateInput = {
    id?: number
    dataCorrecao?: Date | string
    conteudo: string
    codCoordenador: number
    codEntrega: number
  }

  export type CorrecaoUpdateInput = {
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    coordenador?: UsuarioUpdateOneRequiredWithoutCorrecaoNestedInput
    entrega?: EntregaUpdateOneRequiredWithoutCorrecaoNestedInput
  }

  export type CorrecaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    codCoordenador?: IntFieldUpdateOperationsInput | number
    codEntrega?: IntFieldUpdateOperationsInput | number
  }

  export type CorrecaoCreateManyInput = {
    id?: number
    dataCorrecao?: Date | string
    conteudo: string
    codCoordenador: number
    codEntrega: number
  }

  export type CorrecaoUpdateManyMutationInput = {
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
  }

  export type CorrecaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    codCoordenador?: IntFieldUpdateOperationsInput | number
    codEntrega?: IntFieldUpdateOperationsInput | number
  }

  export type HorasCreateInput = {
    horasAnuais: number
    horasConcluidas: number
    ano: number
    aluno: UsuarioCreateNestedOneWithoutHorasInput
  }

  export type HorasUncheckedCreateInput = {
    id?: number
    horasAnuais: number
    horasConcluidas: number
    ano: number
    codAluno: number
  }

  export type HorasUpdateInput = {
    horasAnuais?: IntFieldUpdateOperationsInput | number
    horasConcluidas?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    aluno?: UsuarioUpdateOneRequiredWithoutHorasNestedInput
  }

  export type HorasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    horasAnuais?: IntFieldUpdateOperationsInput | number
    horasConcluidas?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    codAluno?: IntFieldUpdateOperationsInput | number
  }

  export type HorasCreateManyInput = {
    id?: number
    horasAnuais: number
    horasConcluidas: number
    ano: number
    codAluno: number
  }

  export type HorasUpdateManyMutationInput = {
    horasAnuais?: IntFieldUpdateOperationsInput | number
    horasConcluidas?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type HorasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    horasAnuais?: IntFieldUpdateOperationsInput | number
    horasConcluidas?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    codAluno?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type TurmaListRelationFilter = {
    every?: TurmaWhereInput
    some?: TurmaWhereInput
    none?: TurmaWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TurmaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EscolaCountOrderByAggregateInput = {
    id?: SortOrder
    nomeEscola?: SortOrder
  }

  export type EscolaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EscolaMaxOrderByAggregateInput = {
    id?: SortOrder
    nomeEscola?: SortOrder
  }

  export type EscolaMinOrderByAggregateInput = {
    id?: SortOrder
    nomeEscola?: SortOrder
  }

  export type EscolaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EscolaRelationFilter = {
    is?: EscolaWhereInput
    isNot?: EscolaWhereInput
  }

  export type TurmaCountOrderByAggregateInput = {
    id?: SortOrder
    ano?: SortOrder
    nomeTurma?: SortOrder
    codEscola?: SortOrder
  }

  export type TurmaAvgOrderByAggregateInput = {
    id?: SortOrder
    ano?: SortOrder
    codEscola?: SortOrder
  }

  export type TurmaMaxOrderByAggregateInput = {
    id?: SortOrder
    ano?: SortOrder
    nomeTurma?: SortOrder
    codEscola?: SortOrder
  }

  export type TurmaMinOrderByAggregateInput = {
    id?: SortOrder
    ano?: SortOrder
    nomeTurma?: SortOrder
    codEscola?: SortOrder
  }

  export type TurmaSumOrderByAggregateInput = {
    id?: SortOrder
    ano?: SortOrder
    codEscola?: SortOrder
  }

  export type tipoUsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    tipoUsuario?: SortOrder
  }

  export type tipoUsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipoUsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoUsuario?: SortOrder
  }

  export type tipoUsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    tipoUsuario?: SortOrder
  }

  export type tipoUsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EscolaNullableRelationFilter = {
    is?: EscolaWhereInput | null
    isNot?: EscolaWhereInput | null
  }

  export type TipoUsuarioRelationFilter = {
    is?: tipoUsuarioWhereInput
    isNot?: tipoUsuarioWhereInput
  }

  export type TurmaNullableRelationFilter = {
    is?: TurmaWhereInput | null
    isNot?: TurmaWhereInput | null
  }

  export type EntregaListRelationFilter = {
    every?: EntregaWhereInput
    some?: EntregaWhereInput
    none?: EntregaWhereInput
  }

  export type SolicitacaoSuporteListRelationFilter = {
    every?: SolicitacaoSuporteWhereInput
    some?: SolicitacaoSuporteWhereInput
    none?: SolicitacaoSuporteWhereInput
  }

  export type RespostaListRelationFilter = {
    every?: RespostaWhereInput
    some?: RespostaWhereInput
    none?: RespostaWhereInput
  }

  export type CorrecaoListRelationFilter = {
    every?: CorrecaoWhereInput
    some?: CorrecaoWhereInput
    none?: CorrecaoWhereInput
  }

  export type HorasListRelationFilter = {
    every?: HorasWhereInput
    some?: HorasWhereInput
    none?: HorasWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EntregaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SolicitacaoSuporteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RespostaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CorrecaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HorasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nome?: SortOrder
    rm?: SortOrder
    codEscola?: SortOrder
    codTipoUsuario?: SortOrder
    codTurma?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    rm?: SortOrder
    codEscola?: SortOrder
    codTipoUsuario?: SortOrder
    codTurma?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nome?: SortOrder
    rm?: SortOrder
    codEscola?: SortOrder
    codTipoUsuario?: SortOrder
    codTurma?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nome?: SortOrder
    rm?: SortOrder
    codEscola?: SortOrder
    codTipoUsuario?: SortOrder
    codTurma?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
    rm?: SortOrder
    codEscola?: SortOrder
    codTipoUsuario?: SortOrder
    codTurma?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TipoAtividadeRelationFilter = {
    is?: tipoAtividadeWhereInput
    isNot?: tipoAtividadeWhereInput
  }

  export type AtividadeCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    anexos?: SortOrder
    horasAtividade?: SortOrder
    dataCriacao?: SortOrder
    prazoEntrega?: SortOrder
    codTipoAtividade?: SortOrder
  }

  export type AtividadeAvgOrderByAggregateInput = {
    id?: SortOrder
    horasAtividade?: SortOrder
    codTipoAtividade?: SortOrder
  }

  export type AtividadeMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    anexos?: SortOrder
    horasAtividade?: SortOrder
    dataCriacao?: SortOrder
    prazoEntrega?: SortOrder
    codTipoAtividade?: SortOrder
  }

  export type AtividadeMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    anexos?: SortOrder
    horasAtividade?: SortOrder
    dataCriacao?: SortOrder
    prazoEntrega?: SortOrder
    codTipoAtividade?: SortOrder
  }

  export type AtividadeSumOrderByAggregateInput = {
    id?: SortOrder
    horasAtividade?: SortOrder
    codTipoAtividade?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AtividadeListRelationFilter = {
    every?: AtividadeWhereInput
    some?: AtividadeWhereInput
    none?: AtividadeWhereInput
  }

  export type AtividadeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipoAtividadeCountOrderByAggregateInput = {
    id?: SortOrder
    tipoAtividade?: SortOrder
  }

  export type tipoAtividadeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipoAtividadeMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoAtividade?: SortOrder
  }

  export type tipoAtividadeMinOrderByAggregateInput = {
    id?: SortOrder
    tipoAtividade?: SortOrder
  }

  export type tipoAtividadeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type AtividadeRelationFilter = {
    is?: AtividadeWhereInput
    isNot?: AtividadeWhereInput
  }

  export type CorrecaoNullableRelationFilter = {
    is?: CorrecaoWhereInput | null
    isNot?: CorrecaoWhereInput | null
  }

  export type EntregaCountOrderByAggregateInput = {
    id?: SortOrder
    dataEntrega?: SortOrder
    conteudo?: SortOrder
    entregue?: SortOrder
    codAluno?: SortOrder
    codAtividade?: SortOrder
  }

  export type EntregaAvgOrderByAggregateInput = {
    id?: SortOrder
    codAluno?: SortOrder
    codAtividade?: SortOrder
  }

  export type EntregaMaxOrderByAggregateInput = {
    id?: SortOrder
    dataEntrega?: SortOrder
    conteudo?: SortOrder
    entregue?: SortOrder
    codAluno?: SortOrder
    codAtividade?: SortOrder
  }

  export type EntregaMinOrderByAggregateInput = {
    id?: SortOrder
    dataEntrega?: SortOrder
    conteudo?: SortOrder
    entregue?: SortOrder
    codAluno?: SortOrder
    codAtividade?: SortOrder
  }

  export type EntregaSumOrderByAggregateInput = {
    id?: SortOrder
    codAluno?: SortOrder
    codAtividade?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RespostaNullableRelationFilter = {
    is?: RespostaWhereInput | null
    isNot?: RespostaWhereInput | null
  }

  export type SolicitacaoSuporteCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    dataCriacao?: SortOrder
    codAluno?: SortOrder
  }

  export type SolicitacaoSuporteAvgOrderByAggregateInput = {
    id?: SortOrder
    codAluno?: SortOrder
  }

  export type SolicitacaoSuporteMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    dataCriacao?: SortOrder
    codAluno?: SortOrder
  }

  export type SolicitacaoSuporteMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    dataCriacao?: SortOrder
    codAluno?: SortOrder
  }

  export type SolicitacaoSuporteSumOrderByAggregateInput = {
    id?: SortOrder
    codAluno?: SortOrder
  }

  export type SolicitacaoSuporteRelationFilter = {
    is?: SolicitacaoSuporteWhereInput
    isNot?: SolicitacaoSuporteWhereInput
  }

  export type RespostaCountOrderByAggregateInput = {
    id?: SortOrder
    dataResposta?: SortOrder
    resposta?: SortOrder
    codCoordenador?: SortOrder
    codSolicitacao?: SortOrder
  }

  export type RespostaAvgOrderByAggregateInput = {
    id?: SortOrder
    codCoordenador?: SortOrder
    codSolicitacao?: SortOrder
  }

  export type RespostaMaxOrderByAggregateInput = {
    id?: SortOrder
    dataResposta?: SortOrder
    resposta?: SortOrder
    codCoordenador?: SortOrder
    codSolicitacao?: SortOrder
  }

  export type RespostaMinOrderByAggregateInput = {
    id?: SortOrder
    dataResposta?: SortOrder
    resposta?: SortOrder
    codCoordenador?: SortOrder
    codSolicitacao?: SortOrder
  }

  export type RespostaSumOrderByAggregateInput = {
    id?: SortOrder
    codCoordenador?: SortOrder
    codSolicitacao?: SortOrder
  }

  export type EntregaRelationFilter = {
    is?: EntregaWhereInput
    isNot?: EntregaWhereInput
  }

  export type CorrecaoCountOrderByAggregateInput = {
    id?: SortOrder
    dataCorrecao?: SortOrder
    conteudo?: SortOrder
    codCoordenador?: SortOrder
    codEntrega?: SortOrder
  }

  export type CorrecaoAvgOrderByAggregateInput = {
    id?: SortOrder
    codCoordenador?: SortOrder
    codEntrega?: SortOrder
  }

  export type CorrecaoMaxOrderByAggregateInput = {
    id?: SortOrder
    dataCorrecao?: SortOrder
    conteudo?: SortOrder
    codCoordenador?: SortOrder
    codEntrega?: SortOrder
  }

  export type CorrecaoMinOrderByAggregateInput = {
    id?: SortOrder
    dataCorrecao?: SortOrder
    conteudo?: SortOrder
    codCoordenador?: SortOrder
    codEntrega?: SortOrder
  }

  export type CorrecaoSumOrderByAggregateInput = {
    id?: SortOrder
    codCoordenador?: SortOrder
    codEntrega?: SortOrder
  }

  export type HorasCountOrderByAggregateInput = {
    id?: SortOrder
    horasAnuais?: SortOrder
    horasConcluidas?: SortOrder
    ano?: SortOrder
    codAluno?: SortOrder
  }

  export type HorasAvgOrderByAggregateInput = {
    id?: SortOrder
    horasAnuais?: SortOrder
    horasConcluidas?: SortOrder
    ano?: SortOrder
    codAluno?: SortOrder
  }

  export type HorasMaxOrderByAggregateInput = {
    id?: SortOrder
    horasAnuais?: SortOrder
    horasConcluidas?: SortOrder
    ano?: SortOrder
    codAluno?: SortOrder
  }

  export type HorasMinOrderByAggregateInput = {
    id?: SortOrder
    horasAnuais?: SortOrder
    horasConcluidas?: SortOrder
    ano?: SortOrder
    codAluno?: SortOrder
  }

  export type HorasSumOrderByAggregateInput = {
    id?: SortOrder
    horasAnuais?: SortOrder
    horasConcluidas?: SortOrder
    ano?: SortOrder
    codAluno?: SortOrder
  }

  export type UsuarioCreateNestedManyWithoutEscolaRelInput = {
    create?: XOR<UsuarioCreateWithoutEscolaRelInput, UsuarioUncheckedCreateWithoutEscolaRelInput> | UsuarioCreateWithoutEscolaRelInput[] | UsuarioUncheckedCreateWithoutEscolaRelInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEscolaRelInput | UsuarioCreateOrConnectWithoutEscolaRelInput[]
    createMany?: UsuarioCreateManyEscolaRelInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type TurmaCreateNestedManyWithoutEscolaInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutEscolaRelInput = {
    create?: XOR<UsuarioCreateWithoutEscolaRelInput, UsuarioUncheckedCreateWithoutEscolaRelInput> | UsuarioCreateWithoutEscolaRelInput[] | UsuarioUncheckedCreateWithoutEscolaRelInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEscolaRelInput | UsuarioCreateOrConnectWithoutEscolaRelInput[]
    createMany?: UsuarioCreateManyEscolaRelInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type TurmaUncheckedCreateNestedManyWithoutEscolaInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UsuarioUpdateManyWithoutEscolaRelNestedInput = {
    create?: XOR<UsuarioCreateWithoutEscolaRelInput, UsuarioUncheckedCreateWithoutEscolaRelInput> | UsuarioCreateWithoutEscolaRelInput[] | UsuarioUncheckedCreateWithoutEscolaRelInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEscolaRelInput | UsuarioCreateOrConnectWithoutEscolaRelInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEscolaRelInput | UsuarioUpsertWithWhereUniqueWithoutEscolaRelInput[]
    createMany?: UsuarioCreateManyEscolaRelInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEscolaRelInput | UsuarioUpdateWithWhereUniqueWithoutEscolaRelInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEscolaRelInput | UsuarioUpdateManyWithWhereWithoutEscolaRelInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type TurmaUpdateManyWithoutEscolaNestedInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    upsert?: TurmaUpsertWithWhereUniqueWithoutEscolaInput | TurmaUpsertWithWhereUniqueWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    set?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    disconnect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    delete?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    update?: TurmaUpdateWithWhereUniqueWithoutEscolaInput | TurmaUpdateWithWhereUniqueWithoutEscolaInput[]
    updateMany?: TurmaUpdateManyWithWhereWithoutEscolaInput | TurmaUpdateManyWithWhereWithoutEscolaInput[]
    deleteMany?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUncheckedUpdateManyWithoutEscolaRelNestedInput = {
    create?: XOR<UsuarioCreateWithoutEscolaRelInput, UsuarioUncheckedCreateWithoutEscolaRelInput> | UsuarioCreateWithoutEscolaRelInput[] | UsuarioUncheckedCreateWithoutEscolaRelInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutEscolaRelInput | UsuarioCreateOrConnectWithoutEscolaRelInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutEscolaRelInput | UsuarioUpsertWithWhereUniqueWithoutEscolaRelInput[]
    createMany?: UsuarioCreateManyEscolaRelInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutEscolaRelInput | UsuarioUpdateWithWhereUniqueWithoutEscolaRelInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutEscolaRelInput | UsuarioUpdateManyWithWhereWithoutEscolaRelInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type TurmaUncheckedUpdateManyWithoutEscolaNestedInput = {
    create?: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput> | TurmaCreateWithoutEscolaInput[] | TurmaUncheckedCreateWithoutEscolaInput[]
    connectOrCreate?: TurmaCreateOrConnectWithoutEscolaInput | TurmaCreateOrConnectWithoutEscolaInput[]
    upsert?: TurmaUpsertWithWhereUniqueWithoutEscolaInput | TurmaUpsertWithWhereUniqueWithoutEscolaInput[]
    createMany?: TurmaCreateManyEscolaInputEnvelope
    set?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    disconnect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    delete?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    connect?: TurmaWhereUniqueInput | TurmaWhereUniqueInput[]
    update?: TurmaUpdateWithWhereUniqueWithoutEscolaInput | TurmaUpdateWithWhereUniqueWithoutEscolaInput[]
    updateMany?: TurmaUpdateManyWithWhereWithoutEscolaInput | TurmaUpdateManyWithWhereWithoutEscolaInput[]
    deleteMany?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
  }

  export type EscolaCreateNestedOneWithoutTurmaInput = {
    create?: XOR<EscolaCreateWithoutTurmaInput, EscolaUncheckedCreateWithoutTurmaInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutTurmaInput
    connect?: EscolaWhereUniqueInput
  }

  export type UsuarioCreateNestedManyWithoutTurmaInput = {
    create?: XOR<UsuarioCreateWithoutTurmaInput, UsuarioUncheckedCreateWithoutTurmaInput> | UsuarioCreateWithoutTurmaInput[] | UsuarioUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTurmaInput | UsuarioCreateOrConnectWithoutTurmaInput[]
    createMany?: UsuarioCreateManyTurmaInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutTurmaInput = {
    create?: XOR<UsuarioCreateWithoutTurmaInput, UsuarioUncheckedCreateWithoutTurmaInput> | UsuarioCreateWithoutTurmaInput[] | UsuarioUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTurmaInput | UsuarioCreateOrConnectWithoutTurmaInput[]
    createMany?: UsuarioCreateManyTurmaInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type EscolaUpdateOneRequiredWithoutTurmaNestedInput = {
    create?: XOR<EscolaCreateWithoutTurmaInput, EscolaUncheckedCreateWithoutTurmaInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutTurmaInput
    upsert?: EscolaUpsertWithoutTurmaInput
    connect?: EscolaWhereUniqueInput
    update?: XOR<XOR<EscolaUpdateToOneWithWhereWithoutTurmaInput, EscolaUpdateWithoutTurmaInput>, EscolaUncheckedUpdateWithoutTurmaInput>
  }

  export type UsuarioUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<UsuarioCreateWithoutTurmaInput, UsuarioUncheckedCreateWithoutTurmaInput> | UsuarioCreateWithoutTurmaInput[] | UsuarioUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTurmaInput | UsuarioCreateOrConnectWithoutTurmaInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutTurmaInput | UsuarioUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: UsuarioCreateManyTurmaInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutTurmaInput | UsuarioUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutTurmaInput | UsuarioUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutTurmaNestedInput = {
    create?: XOR<UsuarioCreateWithoutTurmaInput, UsuarioUncheckedCreateWithoutTurmaInput> | UsuarioCreateWithoutTurmaInput[] | UsuarioUncheckedCreateWithoutTurmaInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTurmaInput | UsuarioCreateOrConnectWithoutTurmaInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutTurmaInput | UsuarioUpsertWithWhereUniqueWithoutTurmaInput[]
    createMany?: UsuarioCreateManyTurmaInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutTurmaInput | UsuarioUpdateWithWhereUniqueWithoutTurmaInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutTurmaInput | UsuarioUpdateManyWithWhereWithoutTurmaInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type UsuarioCreateNestedManyWithoutTipoUsuarioInput = {
    create?: XOR<UsuarioCreateWithoutTipoUsuarioInput, UsuarioUncheckedCreateWithoutTipoUsuarioInput> | UsuarioCreateWithoutTipoUsuarioInput[] | UsuarioUncheckedCreateWithoutTipoUsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoUsuarioInput | UsuarioCreateOrConnectWithoutTipoUsuarioInput[]
    createMany?: UsuarioCreateManyTipoUsuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutTipoUsuarioInput = {
    create?: XOR<UsuarioCreateWithoutTipoUsuarioInput, UsuarioUncheckedCreateWithoutTipoUsuarioInput> | UsuarioCreateWithoutTipoUsuarioInput[] | UsuarioUncheckedCreateWithoutTipoUsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoUsuarioInput | UsuarioCreateOrConnectWithoutTipoUsuarioInput[]
    createMany?: UsuarioCreateManyTipoUsuarioInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutTipoUsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutTipoUsuarioInput, UsuarioUncheckedCreateWithoutTipoUsuarioInput> | UsuarioCreateWithoutTipoUsuarioInput[] | UsuarioUncheckedCreateWithoutTipoUsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoUsuarioInput | UsuarioCreateOrConnectWithoutTipoUsuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutTipoUsuarioInput | UsuarioUpsertWithWhereUniqueWithoutTipoUsuarioInput[]
    createMany?: UsuarioCreateManyTipoUsuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutTipoUsuarioInput | UsuarioUpdateWithWhereUniqueWithoutTipoUsuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutTipoUsuarioInput | UsuarioUpdateManyWithWhereWithoutTipoUsuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutTipoUsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutTipoUsuarioInput, UsuarioUncheckedCreateWithoutTipoUsuarioInput> | UsuarioCreateWithoutTipoUsuarioInput[] | UsuarioUncheckedCreateWithoutTipoUsuarioInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutTipoUsuarioInput | UsuarioCreateOrConnectWithoutTipoUsuarioInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutTipoUsuarioInput | UsuarioUpsertWithWhereUniqueWithoutTipoUsuarioInput[]
    createMany?: UsuarioCreateManyTipoUsuarioInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutTipoUsuarioInput | UsuarioUpdateWithWhereUniqueWithoutTipoUsuarioInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutTipoUsuarioInput | UsuarioUpdateManyWithWhereWithoutTipoUsuarioInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EscolaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<EscolaCreateWithoutUsuarioInput, EscolaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutUsuarioInput
    connect?: EscolaWhereUniqueInput
  }

  export type tipoUsuarioCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<tipoUsuarioCreateWithoutUsuarioInput, tipoUsuarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: tipoUsuarioCreateOrConnectWithoutUsuarioInput
    connect?: tipoUsuarioWhereUniqueInput
  }

  export type TurmaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<TurmaCreateWithoutUsuarioInput, TurmaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: TurmaCreateOrConnectWithoutUsuarioInput
    connect?: TurmaWhereUniqueInput
  }

  export type EntregaCreateNestedManyWithoutAlunoInput = {
    create?: XOR<EntregaCreateWithoutAlunoInput, EntregaUncheckedCreateWithoutAlunoInput> | EntregaCreateWithoutAlunoInput[] | EntregaUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAlunoInput | EntregaCreateOrConnectWithoutAlunoInput[]
    createMany?: EntregaCreateManyAlunoInputEnvelope
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
  }

  export type SolicitacaoSuporteCreateNestedManyWithoutAlunoInput = {
    create?: XOR<SolicitacaoSuporteCreateWithoutAlunoInput, SolicitacaoSuporteUncheckedCreateWithoutAlunoInput> | SolicitacaoSuporteCreateWithoutAlunoInput[] | SolicitacaoSuporteUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: SolicitacaoSuporteCreateOrConnectWithoutAlunoInput | SolicitacaoSuporteCreateOrConnectWithoutAlunoInput[]
    createMany?: SolicitacaoSuporteCreateManyAlunoInputEnvelope
    connect?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
  }

  export type RespostaCreateNestedManyWithoutCoordenadorInput = {
    create?: XOR<RespostaCreateWithoutCoordenadorInput, RespostaUncheckedCreateWithoutCoordenadorInput> | RespostaCreateWithoutCoordenadorInput[] | RespostaUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: RespostaCreateOrConnectWithoutCoordenadorInput | RespostaCreateOrConnectWithoutCoordenadorInput[]
    createMany?: RespostaCreateManyCoordenadorInputEnvelope
    connect?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
  }

  export type CorrecaoCreateNestedManyWithoutCoordenadorInput = {
    create?: XOR<CorrecaoCreateWithoutCoordenadorInput, CorrecaoUncheckedCreateWithoutCoordenadorInput> | CorrecaoCreateWithoutCoordenadorInput[] | CorrecaoUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: CorrecaoCreateOrConnectWithoutCoordenadorInput | CorrecaoCreateOrConnectWithoutCoordenadorInput[]
    createMany?: CorrecaoCreateManyCoordenadorInputEnvelope
    connect?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
  }

  export type HorasCreateNestedManyWithoutAlunoInput = {
    create?: XOR<HorasCreateWithoutAlunoInput, HorasUncheckedCreateWithoutAlunoInput> | HorasCreateWithoutAlunoInput[] | HorasUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: HorasCreateOrConnectWithoutAlunoInput | HorasCreateOrConnectWithoutAlunoInput[]
    createMany?: HorasCreateManyAlunoInputEnvelope
    connect?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
  }

  export type EntregaUncheckedCreateNestedManyWithoutAlunoInput = {
    create?: XOR<EntregaCreateWithoutAlunoInput, EntregaUncheckedCreateWithoutAlunoInput> | EntregaCreateWithoutAlunoInput[] | EntregaUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAlunoInput | EntregaCreateOrConnectWithoutAlunoInput[]
    createMany?: EntregaCreateManyAlunoInputEnvelope
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
  }

  export type SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput = {
    create?: XOR<SolicitacaoSuporteCreateWithoutAlunoInput, SolicitacaoSuporteUncheckedCreateWithoutAlunoInput> | SolicitacaoSuporteCreateWithoutAlunoInput[] | SolicitacaoSuporteUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: SolicitacaoSuporteCreateOrConnectWithoutAlunoInput | SolicitacaoSuporteCreateOrConnectWithoutAlunoInput[]
    createMany?: SolicitacaoSuporteCreateManyAlunoInputEnvelope
    connect?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
  }

  export type RespostaUncheckedCreateNestedManyWithoutCoordenadorInput = {
    create?: XOR<RespostaCreateWithoutCoordenadorInput, RespostaUncheckedCreateWithoutCoordenadorInput> | RespostaCreateWithoutCoordenadorInput[] | RespostaUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: RespostaCreateOrConnectWithoutCoordenadorInput | RespostaCreateOrConnectWithoutCoordenadorInput[]
    createMany?: RespostaCreateManyCoordenadorInputEnvelope
    connect?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
  }

  export type CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput = {
    create?: XOR<CorrecaoCreateWithoutCoordenadorInput, CorrecaoUncheckedCreateWithoutCoordenadorInput> | CorrecaoCreateWithoutCoordenadorInput[] | CorrecaoUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: CorrecaoCreateOrConnectWithoutCoordenadorInput | CorrecaoCreateOrConnectWithoutCoordenadorInput[]
    createMany?: CorrecaoCreateManyCoordenadorInputEnvelope
    connect?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
  }

  export type HorasUncheckedCreateNestedManyWithoutAlunoInput = {
    create?: XOR<HorasCreateWithoutAlunoInput, HorasUncheckedCreateWithoutAlunoInput> | HorasCreateWithoutAlunoInput[] | HorasUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: HorasCreateOrConnectWithoutAlunoInput | HorasCreateOrConnectWithoutAlunoInput[]
    createMany?: HorasCreateManyAlunoInputEnvelope
    connect?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EscolaUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<EscolaCreateWithoutUsuarioInput, EscolaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: EscolaCreateOrConnectWithoutUsuarioInput
    upsert?: EscolaUpsertWithoutUsuarioInput
    disconnect?: EscolaWhereInput | boolean
    delete?: EscolaWhereInput | boolean
    connect?: EscolaWhereUniqueInput
    update?: XOR<XOR<EscolaUpdateToOneWithWhereWithoutUsuarioInput, EscolaUpdateWithoutUsuarioInput>, EscolaUncheckedUpdateWithoutUsuarioInput>
  }

  export type tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<tipoUsuarioCreateWithoutUsuarioInput, tipoUsuarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: tipoUsuarioCreateOrConnectWithoutUsuarioInput
    upsert?: tipoUsuarioUpsertWithoutUsuarioInput
    connect?: tipoUsuarioWhereUniqueInput
    update?: XOR<XOR<tipoUsuarioUpdateToOneWithWhereWithoutUsuarioInput, tipoUsuarioUpdateWithoutUsuarioInput>, tipoUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type TurmaUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<TurmaCreateWithoutUsuarioInput, TurmaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: TurmaCreateOrConnectWithoutUsuarioInput
    upsert?: TurmaUpsertWithoutUsuarioInput
    disconnect?: TurmaWhereInput | boolean
    delete?: TurmaWhereInput | boolean
    connect?: TurmaWhereUniqueInput
    update?: XOR<XOR<TurmaUpdateToOneWithWhereWithoutUsuarioInput, TurmaUpdateWithoutUsuarioInput>, TurmaUncheckedUpdateWithoutUsuarioInput>
  }

  export type EntregaUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<EntregaCreateWithoutAlunoInput, EntregaUncheckedCreateWithoutAlunoInput> | EntregaCreateWithoutAlunoInput[] | EntregaUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAlunoInput | EntregaCreateOrConnectWithoutAlunoInput[]
    upsert?: EntregaUpsertWithWhereUniqueWithoutAlunoInput | EntregaUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: EntregaCreateManyAlunoInputEnvelope
    set?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    disconnect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    delete?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    update?: EntregaUpdateWithWhereUniqueWithoutAlunoInput | EntregaUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: EntregaUpdateManyWithWhereWithoutAlunoInput | EntregaUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: EntregaScalarWhereInput | EntregaScalarWhereInput[]
  }

  export type SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<SolicitacaoSuporteCreateWithoutAlunoInput, SolicitacaoSuporteUncheckedCreateWithoutAlunoInput> | SolicitacaoSuporteCreateWithoutAlunoInput[] | SolicitacaoSuporteUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: SolicitacaoSuporteCreateOrConnectWithoutAlunoInput | SolicitacaoSuporteCreateOrConnectWithoutAlunoInput[]
    upsert?: SolicitacaoSuporteUpsertWithWhereUniqueWithoutAlunoInput | SolicitacaoSuporteUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: SolicitacaoSuporteCreateManyAlunoInputEnvelope
    set?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    disconnect?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    delete?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    connect?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    update?: SolicitacaoSuporteUpdateWithWhereUniqueWithoutAlunoInput | SolicitacaoSuporteUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: SolicitacaoSuporteUpdateManyWithWhereWithoutAlunoInput | SolicitacaoSuporteUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: SolicitacaoSuporteScalarWhereInput | SolicitacaoSuporteScalarWhereInput[]
  }

  export type RespostaUpdateManyWithoutCoordenadorNestedInput = {
    create?: XOR<RespostaCreateWithoutCoordenadorInput, RespostaUncheckedCreateWithoutCoordenadorInput> | RespostaCreateWithoutCoordenadorInput[] | RespostaUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: RespostaCreateOrConnectWithoutCoordenadorInput | RespostaCreateOrConnectWithoutCoordenadorInput[]
    upsert?: RespostaUpsertWithWhereUniqueWithoutCoordenadorInput | RespostaUpsertWithWhereUniqueWithoutCoordenadorInput[]
    createMany?: RespostaCreateManyCoordenadorInputEnvelope
    set?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    disconnect?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    delete?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    connect?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    update?: RespostaUpdateWithWhereUniqueWithoutCoordenadorInput | RespostaUpdateWithWhereUniqueWithoutCoordenadorInput[]
    updateMany?: RespostaUpdateManyWithWhereWithoutCoordenadorInput | RespostaUpdateManyWithWhereWithoutCoordenadorInput[]
    deleteMany?: RespostaScalarWhereInput | RespostaScalarWhereInput[]
  }

  export type CorrecaoUpdateManyWithoutCoordenadorNestedInput = {
    create?: XOR<CorrecaoCreateWithoutCoordenadorInput, CorrecaoUncheckedCreateWithoutCoordenadorInput> | CorrecaoCreateWithoutCoordenadorInput[] | CorrecaoUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: CorrecaoCreateOrConnectWithoutCoordenadorInput | CorrecaoCreateOrConnectWithoutCoordenadorInput[]
    upsert?: CorrecaoUpsertWithWhereUniqueWithoutCoordenadorInput | CorrecaoUpsertWithWhereUniqueWithoutCoordenadorInput[]
    createMany?: CorrecaoCreateManyCoordenadorInputEnvelope
    set?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    disconnect?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    delete?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    connect?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    update?: CorrecaoUpdateWithWhereUniqueWithoutCoordenadorInput | CorrecaoUpdateWithWhereUniqueWithoutCoordenadorInput[]
    updateMany?: CorrecaoUpdateManyWithWhereWithoutCoordenadorInput | CorrecaoUpdateManyWithWhereWithoutCoordenadorInput[]
    deleteMany?: CorrecaoScalarWhereInput | CorrecaoScalarWhereInput[]
  }

  export type HorasUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<HorasCreateWithoutAlunoInput, HorasUncheckedCreateWithoutAlunoInput> | HorasCreateWithoutAlunoInput[] | HorasUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: HorasCreateOrConnectWithoutAlunoInput | HorasCreateOrConnectWithoutAlunoInput[]
    upsert?: HorasUpsertWithWhereUniqueWithoutAlunoInput | HorasUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: HorasCreateManyAlunoInputEnvelope
    set?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    disconnect?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    delete?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    connect?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    update?: HorasUpdateWithWhereUniqueWithoutAlunoInput | HorasUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: HorasUpdateManyWithWhereWithoutAlunoInput | HorasUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: HorasScalarWhereInput | HorasScalarWhereInput[]
  }

  export type EntregaUncheckedUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<EntregaCreateWithoutAlunoInput, EntregaUncheckedCreateWithoutAlunoInput> | EntregaCreateWithoutAlunoInput[] | EntregaUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAlunoInput | EntregaCreateOrConnectWithoutAlunoInput[]
    upsert?: EntregaUpsertWithWhereUniqueWithoutAlunoInput | EntregaUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: EntregaCreateManyAlunoInputEnvelope
    set?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    disconnect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    delete?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    update?: EntregaUpdateWithWhereUniqueWithoutAlunoInput | EntregaUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: EntregaUpdateManyWithWhereWithoutAlunoInput | EntregaUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: EntregaScalarWhereInput | EntregaScalarWhereInput[]
  }

  export type SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<SolicitacaoSuporteCreateWithoutAlunoInput, SolicitacaoSuporteUncheckedCreateWithoutAlunoInput> | SolicitacaoSuporteCreateWithoutAlunoInput[] | SolicitacaoSuporteUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: SolicitacaoSuporteCreateOrConnectWithoutAlunoInput | SolicitacaoSuporteCreateOrConnectWithoutAlunoInput[]
    upsert?: SolicitacaoSuporteUpsertWithWhereUniqueWithoutAlunoInput | SolicitacaoSuporteUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: SolicitacaoSuporteCreateManyAlunoInputEnvelope
    set?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    disconnect?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    delete?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    connect?: SolicitacaoSuporteWhereUniqueInput | SolicitacaoSuporteWhereUniqueInput[]
    update?: SolicitacaoSuporteUpdateWithWhereUniqueWithoutAlunoInput | SolicitacaoSuporteUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: SolicitacaoSuporteUpdateManyWithWhereWithoutAlunoInput | SolicitacaoSuporteUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: SolicitacaoSuporteScalarWhereInput | SolicitacaoSuporteScalarWhereInput[]
  }

  export type RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput = {
    create?: XOR<RespostaCreateWithoutCoordenadorInput, RespostaUncheckedCreateWithoutCoordenadorInput> | RespostaCreateWithoutCoordenadorInput[] | RespostaUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: RespostaCreateOrConnectWithoutCoordenadorInput | RespostaCreateOrConnectWithoutCoordenadorInput[]
    upsert?: RespostaUpsertWithWhereUniqueWithoutCoordenadorInput | RespostaUpsertWithWhereUniqueWithoutCoordenadorInput[]
    createMany?: RespostaCreateManyCoordenadorInputEnvelope
    set?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    disconnect?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    delete?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    connect?: RespostaWhereUniqueInput | RespostaWhereUniqueInput[]
    update?: RespostaUpdateWithWhereUniqueWithoutCoordenadorInput | RespostaUpdateWithWhereUniqueWithoutCoordenadorInput[]
    updateMany?: RespostaUpdateManyWithWhereWithoutCoordenadorInput | RespostaUpdateManyWithWhereWithoutCoordenadorInput[]
    deleteMany?: RespostaScalarWhereInput | RespostaScalarWhereInput[]
  }

  export type CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput = {
    create?: XOR<CorrecaoCreateWithoutCoordenadorInput, CorrecaoUncheckedCreateWithoutCoordenadorInput> | CorrecaoCreateWithoutCoordenadorInput[] | CorrecaoUncheckedCreateWithoutCoordenadorInput[]
    connectOrCreate?: CorrecaoCreateOrConnectWithoutCoordenadorInput | CorrecaoCreateOrConnectWithoutCoordenadorInput[]
    upsert?: CorrecaoUpsertWithWhereUniqueWithoutCoordenadorInput | CorrecaoUpsertWithWhereUniqueWithoutCoordenadorInput[]
    createMany?: CorrecaoCreateManyCoordenadorInputEnvelope
    set?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    disconnect?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    delete?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    connect?: CorrecaoWhereUniqueInput | CorrecaoWhereUniqueInput[]
    update?: CorrecaoUpdateWithWhereUniqueWithoutCoordenadorInput | CorrecaoUpdateWithWhereUniqueWithoutCoordenadorInput[]
    updateMany?: CorrecaoUpdateManyWithWhereWithoutCoordenadorInput | CorrecaoUpdateManyWithWhereWithoutCoordenadorInput[]
    deleteMany?: CorrecaoScalarWhereInput | CorrecaoScalarWhereInput[]
  }

  export type HorasUncheckedUpdateManyWithoutAlunoNestedInput = {
    create?: XOR<HorasCreateWithoutAlunoInput, HorasUncheckedCreateWithoutAlunoInput> | HorasCreateWithoutAlunoInput[] | HorasUncheckedCreateWithoutAlunoInput[]
    connectOrCreate?: HorasCreateOrConnectWithoutAlunoInput | HorasCreateOrConnectWithoutAlunoInput[]
    upsert?: HorasUpsertWithWhereUniqueWithoutAlunoInput | HorasUpsertWithWhereUniqueWithoutAlunoInput[]
    createMany?: HorasCreateManyAlunoInputEnvelope
    set?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    disconnect?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    delete?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    connect?: HorasWhereUniqueInput | HorasWhereUniqueInput[]
    update?: HorasUpdateWithWhereUniqueWithoutAlunoInput | HorasUpdateWithWhereUniqueWithoutAlunoInput[]
    updateMany?: HorasUpdateManyWithWhereWithoutAlunoInput | HorasUpdateManyWithWhereWithoutAlunoInput[]
    deleteMany?: HorasScalarWhereInput | HorasScalarWhereInput[]
  }

  export type tipoAtividadeCreateNestedOneWithoutAtividadeInput = {
    create?: XOR<tipoAtividadeCreateWithoutAtividadeInput, tipoAtividadeUncheckedCreateWithoutAtividadeInput>
    connectOrCreate?: tipoAtividadeCreateOrConnectWithoutAtividadeInput
    connect?: tipoAtividadeWhereUniqueInput
  }

  export type EntregaCreateNestedManyWithoutAtividadeInput = {
    create?: XOR<EntregaCreateWithoutAtividadeInput, EntregaUncheckedCreateWithoutAtividadeInput> | EntregaCreateWithoutAtividadeInput[] | EntregaUncheckedCreateWithoutAtividadeInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAtividadeInput | EntregaCreateOrConnectWithoutAtividadeInput[]
    createMany?: EntregaCreateManyAtividadeInputEnvelope
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
  }

  export type EntregaUncheckedCreateNestedManyWithoutAtividadeInput = {
    create?: XOR<EntregaCreateWithoutAtividadeInput, EntregaUncheckedCreateWithoutAtividadeInput> | EntregaCreateWithoutAtividadeInput[] | EntregaUncheckedCreateWithoutAtividadeInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAtividadeInput | EntregaCreateOrConnectWithoutAtividadeInput[]
    createMany?: EntregaCreateManyAtividadeInputEnvelope
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type tipoAtividadeUpdateOneRequiredWithoutAtividadeNestedInput = {
    create?: XOR<tipoAtividadeCreateWithoutAtividadeInput, tipoAtividadeUncheckedCreateWithoutAtividadeInput>
    connectOrCreate?: tipoAtividadeCreateOrConnectWithoutAtividadeInput
    upsert?: tipoAtividadeUpsertWithoutAtividadeInput
    connect?: tipoAtividadeWhereUniqueInput
    update?: XOR<XOR<tipoAtividadeUpdateToOneWithWhereWithoutAtividadeInput, tipoAtividadeUpdateWithoutAtividadeInput>, tipoAtividadeUncheckedUpdateWithoutAtividadeInput>
  }

  export type EntregaUpdateManyWithoutAtividadeNestedInput = {
    create?: XOR<EntregaCreateWithoutAtividadeInput, EntregaUncheckedCreateWithoutAtividadeInput> | EntregaCreateWithoutAtividadeInput[] | EntregaUncheckedCreateWithoutAtividadeInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAtividadeInput | EntregaCreateOrConnectWithoutAtividadeInput[]
    upsert?: EntregaUpsertWithWhereUniqueWithoutAtividadeInput | EntregaUpsertWithWhereUniqueWithoutAtividadeInput[]
    createMany?: EntregaCreateManyAtividadeInputEnvelope
    set?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    disconnect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    delete?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    update?: EntregaUpdateWithWhereUniqueWithoutAtividadeInput | EntregaUpdateWithWhereUniqueWithoutAtividadeInput[]
    updateMany?: EntregaUpdateManyWithWhereWithoutAtividadeInput | EntregaUpdateManyWithWhereWithoutAtividadeInput[]
    deleteMany?: EntregaScalarWhereInput | EntregaScalarWhereInput[]
  }

  export type EntregaUncheckedUpdateManyWithoutAtividadeNestedInput = {
    create?: XOR<EntregaCreateWithoutAtividadeInput, EntregaUncheckedCreateWithoutAtividadeInput> | EntregaCreateWithoutAtividadeInput[] | EntregaUncheckedCreateWithoutAtividadeInput[]
    connectOrCreate?: EntregaCreateOrConnectWithoutAtividadeInput | EntregaCreateOrConnectWithoutAtividadeInput[]
    upsert?: EntregaUpsertWithWhereUniqueWithoutAtividadeInput | EntregaUpsertWithWhereUniqueWithoutAtividadeInput[]
    createMany?: EntregaCreateManyAtividadeInputEnvelope
    set?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    disconnect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    delete?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    connect?: EntregaWhereUniqueInput | EntregaWhereUniqueInput[]
    update?: EntregaUpdateWithWhereUniqueWithoutAtividadeInput | EntregaUpdateWithWhereUniqueWithoutAtividadeInput[]
    updateMany?: EntregaUpdateManyWithWhereWithoutAtividadeInput | EntregaUpdateManyWithWhereWithoutAtividadeInput[]
    deleteMany?: EntregaScalarWhereInput | EntregaScalarWhereInput[]
  }

  export type AtividadeCreateNestedManyWithoutTipoAtividadeInput = {
    create?: XOR<AtividadeCreateWithoutTipoAtividadeInput, AtividadeUncheckedCreateWithoutTipoAtividadeInput> | AtividadeCreateWithoutTipoAtividadeInput[] | AtividadeUncheckedCreateWithoutTipoAtividadeInput[]
    connectOrCreate?: AtividadeCreateOrConnectWithoutTipoAtividadeInput | AtividadeCreateOrConnectWithoutTipoAtividadeInput[]
    createMany?: AtividadeCreateManyTipoAtividadeInputEnvelope
    connect?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
  }

  export type AtividadeUncheckedCreateNestedManyWithoutTipoAtividadeInput = {
    create?: XOR<AtividadeCreateWithoutTipoAtividadeInput, AtividadeUncheckedCreateWithoutTipoAtividadeInput> | AtividadeCreateWithoutTipoAtividadeInput[] | AtividadeUncheckedCreateWithoutTipoAtividadeInput[]
    connectOrCreate?: AtividadeCreateOrConnectWithoutTipoAtividadeInput | AtividadeCreateOrConnectWithoutTipoAtividadeInput[]
    createMany?: AtividadeCreateManyTipoAtividadeInputEnvelope
    connect?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
  }

  export type AtividadeUpdateManyWithoutTipoAtividadeNestedInput = {
    create?: XOR<AtividadeCreateWithoutTipoAtividadeInput, AtividadeUncheckedCreateWithoutTipoAtividadeInput> | AtividadeCreateWithoutTipoAtividadeInput[] | AtividadeUncheckedCreateWithoutTipoAtividadeInput[]
    connectOrCreate?: AtividadeCreateOrConnectWithoutTipoAtividadeInput | AtividadeCreateOrConnectWithoutTipoAtividadeInput[]
    upsert?: AtividadeUpsertWithWhereUniqueWithoutTipoAtividadeInput | AtividadeUpsertWithWhereUniqueWithoutTipoAtividadeInput[]
    createMany?: AtividadeCreateManyTipoAtividadeInputEnvelope
    set?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    disconnect?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    delete?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    connect?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    update?: AtividadeUpdateWithWhereUniqueWithoutTipoAtividadeInput | AtividadeUpdateWithWhereUniqueWithoutTipoAtividadeInput[]
    updateMany?: AtividadeUpdateManyWithWhereWithoutTipoAtividadeInput | AtividadeUpdateManyWithWhereWithoutTipoAtividadeInput[]
    deleteMany?: AtividadeScalarWhereInput | AtividadeScalarWhereInput[]
  }

  export type AtividadeUncheckedUpdateManyWithoutTipoAtividadeNestedInput = {
    create?: XOR<AtividadeCreateWithoutTipoAtividadeInput, AtividadeUncheckedCreateWithoutTipoAtividadeInput> | AtividadeCreateWithoutTipoAtividadeInput[] | AtividadeUncheckedCreateWithoutTipoAtividadeInput[]
    connectOrCreate?: AtividadeCreateOrConnectWithoutTipoAtividadeInput | AtividadeCreateOrConnectWithoutTipoAtividadeInput[]
    upsert?: AtividadeUpsertWithWhereUniqueWithoutTipoAtividadeInput | AtividadeUpsertWithWhereUniqueWithoutTipoAtividadeInput[]
    createMany?: AtividadeCreateManyTipoAtividadeInputEnvelope
    set?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    disconnect?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    delete?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    connect?: AtividadeWhereUniqueInput | AtividadeWhereUniqueInput[]
    update?: AtividadeUpdateWithWhereUniqueWithoutTipoAtividadeInput | AtividadeUpdateWithWhereUniqueWithoutTipoAtividadeInput[]
    updateMany?: AtividadeUpdateManyWithWhereWithoutTipoAtividadeInput | AtividadeUpdateManyWithWhereWithoutTipoAtividadeInput[]
    deleteMany?: AtividadeScalarWhereInput | AtividadeScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutEntregaInput = {
    create?: XOR<UsuarioCreateWithoutEntregaInput, UsuarioUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEntregaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type AtividadeCreateNestedOneWithoutEntregaInput = {
    create?: XOR<AtividadeCreateWithoutEntregaInput, AtividadeUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: AtividadeCreateOrConnectWithoutEntregaInput
    connect?: AtividadeWhereUniqueInput
  }

  export type CorrecaoCreateNestedOneWithoutEntregaInput = {
    create?: XOR<CorrecaoCreateWithoutEntregaInput, CorrecaoUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: CorrecaoCreateOrConnectWithoutEntregaInput
    connect?: CorrecaoWhereUniqueInput
  }

  export type CorrecaoUncheckedCreateNestedOneWithoutEntregaInput = {
    create?: XOR<CorrecaoCreateWithoutEntregaInput, CorrecaoUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: CorrecaoCreateOrConnectWithoutEntregaInput
    connect?: CorrecaoWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsuarioUpdateOneRequiredWithoutEntregaNestedInput = {
    create?: XOR<UsuarioCreateWithoutEntregaInput, UsuarioUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEntregaInput
    upsert?: UsuarioUpsertWithoutEntregaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEntregaInput, UsuarioUpdateWithoutEntregaInput>, UsuarioUncheckedUpdateWithoutEntregaInput>
  }

  export type AtividadeUpdateOneRequiredWithoutEntregaNestedInput = {
    create?: XOR<AtividadeCreateWithoutEntregaInput, AtividadeUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: AtividadeCreateOrConnectWithoutEntregaInput
    upsert?: AtividadeUpsertWithoutEntregaInput
    connect?: AtividadeWhereUniqueInput
    update?: XOR<XOR<AtividadeUpdateToOneWithWhereWithoutEntregaInput, AtividadeUpdateWithoutEntregaInput>, AtividadeUncheckedUpdateWithoutEntregaInput>
  }

  export type CorrecaoUpdateOneWithoutEntregaNestedInput = {
    create?: XOR<CorrecaoCreateWithoutEntregaInput, CorrecaoUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: CorrecaoCreateOrConnectWithoutEntregaInput
    upsert?: CorrecaoUpsertWithoutEntregaInput
    disconnect?: CorrecaoWhereInput | boolean
    delete?: CorrecaoWhereInput | boolean
    connect?: CorrecaoWhereUniqueInput
    update?: XOR<XOR<CorrecaoUpdateToOneWithWhereWithoutEntregaInput, CorrecaoUpdateWithoutEntregaInput>, CorrecaoUncheckedUpdateWithoutEntregaInput>
  }

  export type CorrecaoUncheckedUpdateOneWithoutEntregaNestedInput = {
    create?: XOR<CorrecaoCreateWithoutEntregaInput, CorrecaoUncheckedCreateWithoutEntregaInput>
    connectOrCreate?: CorrecaoCreateOrConnectWithoutEntregaInput
    upsert?: CorrecaoUpsertWithoutEntregaInput
    disconnect?: CorrecaoWhereInput | boolean
    delete?: CorrecaoWhereInput | boolean
    connect?: CorrecaoWhereUniqueInput
    update?: XOR<XOR<CorrecaoUpdateToOneWithWhereWithoutEntregaInput, CorrecaoUpdateWithoutEntregaInput>, CorrecaoUncheckedUpdateWithoutEntregaInput>
  }

  export type UsuarioCreateNestedOneWithoutSolicitacaoSuporteInput = {
    create?: XOR<UsuarioCreateWithoutSolicitacaoSuporteInput, UsuarioUncheckedCreateWithoutSolicitacaoSuporteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSolicitacaoSuporteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RespostaCreateNestedOneWithoutSolicitacaoSuporteInput = {
    create?: XOR<RespostaCreateWithoutSolicitacaoSuporteInput, RespostaUncheckedCreateWithoutSolicitacaoSuporteInput>
    connectOrCreate?: RespostaCreateOrConnectWithoutSolicitacaoSuporteInput
    connect?: RespostaWhereUniqueInput
  }

  export type RespostaUncheckedCreateNestedOneWithoutSolicitacaoSuporteInput = {
    create?: XOR<RespostaCreateWithoutSolicitacaoSuporteInput, RespostaUncheckedCreateWithoutSolicitacaoSuporteInput>
    connectOrCreate?: RespostaCreateOrConnectWithoutSolicitacaoSuporteInput
    connect?: RespostaWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutSolicitacaoSuporteNestedInput = {
    create?: XOR<UsuarioCreateWithoutSolicitacaoSuporteInput, UsuarioUncheckedCreateWithoutSolicitacaoSuporteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSolicitacaoSuporteInput
    upsert?: UsuarioUpsertWithoutSolicitacaoSuporteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutSolicitacaoSuporteInput, UsuarioUpdateWithoutSolicitacaoSuporteInput>, UsuarioUncheckedUpdateWithoutSolicitacaoSuporteInput>
  }

  export type RespostaUpdateOneWithoutSolicitacaoSuporteNestedInput = {
    create?: XOR<RespostaCreateWithoutSolicitacaoSuporteInput, RespostaUncheckedCreateWithoutSolicitacaoSuporteInput>
    connectOrCreate?: RespostaCreateOrConnectWithoutSolicitacaoSuporteInput
    upsert?: RespostaUpsertWithoutSolicitacaoSuporteInput
    disconnect?: RespostaWhereInput | boolean
    delete?: RespostaWhereInput | boolean
    connect?: RespostaWhereUniqueInput
    update?: XOR<XOR<RespostaUpdateToOneWithWhereWithoutSolicitacaoSuporteInput, RespostaUpdateWithoutSolicitacaoSuporteInput>, RespostaUncheckedUpdateWithoutSolicitacaoSuporteInput>
  }

  export type RespostaUncheckedUpdateOneWithoutSolicitacaoSuporteNestedInput = {
    create?: XOR<RespostaCreateWithoutSolicitacaoSuporteInput, RespostaUncheckedCreateWithoutSolicitacaoSuporteInput>
    connectOrCreate?: RespostaCreateOrConnectWithoutSolicitacaoSuporteInput
    upsert?: RespostaUpsertWithoutSolicitacaoSuporteInput
    disconnect?: RespostaWhereInput | boolean
    delete?: RespostaWhereInput | boolean
    connect?: RespostaWhereUniqueInput
    update?: XOR<XOR<RespostaUpdateToOneWithWhereWithoutSolicitacaoSuporteInput, RespostaUpdateWithoutSolicitacaoSuporteInput>, RespostaUncheckedUpdateWithoutSolicitacaoSuporteInput>
  }

  export type UsuarioCreateNestedOneWithoutRespostaInput = {
    create?: XOR<UsuarioCreateWithoutRespostaInput, UsuarioUncheckedCreateWithoutRespostaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRespostaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type SolicitacaoSuporteCreateNestedOneWithoutRespostaInput = {
    create?: XOR<SolicitacaoSuporteCreateWithoutRespostaInput, SolicitacaoSuporteUncheckedCreateWithoutRespostaInput>
    connectOrCreate?: SolicitacaoSuporteCreateOrConnectWithoutRespostaInput
    connect?: SolicitacaoSuporteWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutRespostaNestedInput = {
    create?: XOR<UsuarioCreateWithoutRespostaInput, UsuarioUncheckedCreateWithoutRespostaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRespostaInput
    upsert?: UsuarioUpsertWithoutRespostaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRespostaInput, UsuarioUpdateWithoutRespostaInput>, UsuarioUncheckedUpdateWithoutRespostaInput>
  }

  export type SolicitacaoSuporteUpdateOneRequiredWithoutRespostaNestedInput = {
    create?: XOR<SolicitacaoSuporteCreateWithoutRespostaInput, SolicitacaoSuporteUncheckedCreateWithoutRespostaInput>
    connectOrCreate?: SolicitacaoSuporteCreateOrConnectWithoutRespostaInput
    upsert?: SolicitacaoSuporteUpsertWithoutRespostaInput
    connect?: SolicitacaoSuporteWhereUniqueInput
    update?: XOR<XOR<SolicitacaoSuporteUpdateToOneWithWhereWithoutRespostaInput, SolicitacaoSuporteUpdateWithoutRespostaInput>, SolicitacaoSuporteUncheckedUpdateWithoutRespostaInput>
  }

  export type UsuarioCreateNestedOneWithoutCorrecaoInput = {
    create?: XOR<UsuarioCreateWithoutCorrecaoInput, UsuarioUncheckedCreateWithoutCorrecaoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCorrecaoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EntregaCreateNestedOneWithoutCorrecaoInput = {
    create?: XOR<EntregaCreateWithoutCorrecaoInput, EntregaUncheckedCreateWithoutCorrecaoInput>
    connectOrCreate?: EntregaCreateOrConnectWithoutCorrecaoInput
    connect?: EntregaWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutCorrecaoNestedInput = {
    create?: XOR<UsuarioCreateWithoutCorrecaoInput, UsuarioUncheckedCreateWithoutCorrecaoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCorrecaoInput
    upsert?: UsuarioUpsertWithoutCorrecaoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCorrecaoInput, UsuarioUpdateWithoutCorrecaoInput>, UsuarioUncheckedUpdateWithoutCorrecaoInput>
  }

  export type EntregaUpdateOneRequiredWithoutCorrecaoNestedInput = {
    create?: XOR<EntregaCreateWithoutCorrecaoInput, EntregaUncheckedCreateWithoutCorrecaoInput>
    connectOrCreate?: EntregaCreateOrConnectWithoutCorrecaoInput
    upsert?: EntregaUpsertWithoutCorrecaoInput
    connect?: EntregaWhereUniqueInput
    update?: XOR<XOR<EntregaUpdateToOneWithWhereWithoutCorrecaoInput, EntregaUpdateWithoutCorrecaoInput>, EntregaUncheckedUpdateWithoutCorrecaoInput>
  }

  export type UsuarioCreateNestedOneWithoutHorasInput = {
    create?: XOR<UsuarioCreateWithoutHorasInput, UsuarioUncheckedCreateWithoutHorasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHorasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutHorasNestedInput = {
    create?: XOR<UsuarioCreateWithoutHorasInput, UsuarioUncheckedCreateWithoutHorasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHorasInput
    upsert?: UsuarioUpsertWithoutHorasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutHorasInput, UsuarioUpdateWithoutHorasInput>, UsuarioUncheckedUpdateWithoutHorasInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UsuarioCreateWithoutEscolaRelInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateWithoutEscolaRelInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codTipoUsuario: number
    codTurma?: number | null
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioCreateOrConnectWithoutEscolaRelInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEscolaRelInput, UsuarioUncheckedCreateWithoutEscolaRelInput>
  }

  export type UsuarioCreateManyEscolaRelInputEnvelope = {
    data: UsuarioCreateManyEscolaRelInput | UsuarioCreateManyEscolaRelInput[]
    skipDuplicates?: boolean
  }

  export type TurmaCreateWithoutEscolaInput = {
    ano: number
    nomeTurma: string
    Usuario?: UsuarioCreateNestedManyWithoutTurmaInput
  }

  export type TurmaUncheckedCreateWithoutEscolaInput = {
    id?: number
    ano: number
    nomeTurma: string
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutTurmaInput
  }

  export type TurmaCreateOrConnectWithoutEscolaInput = {
    where: TurmaWhereUniqueInput
    create: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput>
  }

  export type TurmaCreateManyEscolaInputEnvelope = {
    data: TurmaCreateManyEscolaInput | TurmaCreateManyEscolaInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutEscolaRelInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutEscolaRelInput, UsuarioUncheckedUpdateWithoutEscolaRelInput>
    create: XOR<UsuarioCreateWithoutEscolaRelInput, UsuarioUncheckedCreateWithoutEscolaRelInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutEscolaRelInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutEscolaRelInput, UsuarioUncheckedUpdateWithoutEscolaRelInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutEscolaRelInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutEscolaRelInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: IntFilter<"Usuario"> | number
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    rm?: IntNullableFilter<"Usuario"> | number | null
    codEscola?: IntNullableFilter<"Usuario"> | number | null
    codTipoUsuario?: IntFilter<"Usuario"> | number
    codTurma?: IntNullableFilter<"Usuario"> | number | null
  }

  export type TurmaUpsertWithWhereUniqueWithoutEscolaInput = {
    where: TurmaWhereUniqueInput
    update: XOR<TurmaUpdateWithoutEscolaInput, TurmaUncheckedUpdateWithoutEscolaInput>
    create: XOR<TurmaCreateWithoutEscolaInput, TurmaUncheckedCreateWithoutEscolaInput>
  }

  export type TurmaUpdateWithWhereUniqueWithoutEscolaInput = {
    where: TurmaWhereUniqueInput
    data: XOR<TurmaUpdateWithoutEscolaInput, TurmaUncheckedUpdateWithoutEscolaInput>
  }

  export type TurmaUpdateManyWithWhereWithoutEscolaInput = {
    where: TurmaScalarWhereInput
    data: XOR<TurmaUpdateManyMutationInput, TurmaUncheckedUpdateManyWithoutEscolaInput>
  }

  export type TurmaScalarWhereInput = {
    AND?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
    OR?: TurmaScalarWhereInput[]
    NOT?: TurmaScalarWhereInput | TurmaScalarWhereInput[]
    id?: IntFilter<"Turma"> | number
    ano?: IntFilter<"Turma"> | number
    nomeTurma?: StringFilter<"Turma"> | string
    codEscola?: IntFilter<"Turma"> | number
  }

  export type EscolaCreateWithoutTurmaInput = {
    nomeEscola: string
    Usuario?: UsuarioCreateNestedManyWithoutEscolaRelInput
  }

  export type EscolaUncheckedCreateWithoutTurmaInput = {
    id?: number
    nomeEscola: string
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutEscolaRelInput
  }

  export type EscolaCreateOrConnectWithoutTurmaInput = {
    where: EscolaWhereUniqueInput
    create: XOR<EscolaCreateWithoutTurmaInput, EscolaUncheckedCreateWithoutTurmaInput>
  }

  export type UsuarioCreateWithoutTurmaInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateWithoutTurmaInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioCreateOrConnectWithoutTurmaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTurmaInput, UsuarioUncheckedCreateWithoutTurmaInput>
  }

  export type UsuarioCreateManyTurmaInputEnvelope = {
    data: UsuarioCreateManyTurmaInput | UsuarioCreateManyTurmaInput[]
    skipDuplicates?: boolean
  }

  export type EscolaUpsertWithoutTurmaInput = {
    update: XOR<EscolaUpdateWithoutTurmaInput, EscolaUncheckedUpdateWithoutTurmaInput>
    create: XOR<EscolaCreateWithoutTurmaInput, EscolaUncheckedCreateWithoutTurmaInput>
    where?: EscolaWhereInput
  }

  export type EscolaUpdateToOneWithWhereWithoutTurmaInput = {
    where?: EscolaWhereInput
    data: XOR<EscolaUpdateWithoutTurmaInput, EscolaUncheckedUpdateWithoutTurmaInput>
  }

  export type EscolaUpdateWithoutTurmaInput = {
    nomeEscola?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateManyWithoutEscolaRelNestedInput
  }

  export type EscolaUncheckedUpdateWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUncheckedUpdateManyWithoutEscolaRelNestedInput
  }

  export type UsuarioUpsertWithWhereUniqueWithoutTurmaInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutTurmaInput, UsuarioUncheckedUpdateWithoutTurmaInput>
    create: XOR<UsuarioCreateWithoutTurmaInput, UsuarioUncheckedCreateWithoutTurmaInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutTurmaInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutTurmaInput, UsuarioUncheckedUpdateWithoutTurmaInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutTurmaInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutTurmaInput>
  }

  export type UsuarioCreateWithoutTipoUsuarioInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateWithoutTipoUsuarioInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTurma?: number | null
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioCreateOrConnectWithoutTipoUsuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTipoUsuarioInput, UsuarioUncheckedCreateWithoutTipoUsuarioInput>
  }

  export type UsuarioCreateManyTipoUsuarioInputEnvelope = {
    data: UsuarioCreateManyTipoUsuarioInput | UsuarioCreateManyTipoUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithWhereUniqueWithoutTipoUsuarioInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutTipoUsuarioInput, UsuarioUncheckedUpdateWithoutTipoUsuarioInput>
    create: XOR<UsuarioCreateWithoutTipoUsuarioInput, UsuarioUncheckedCreateWithoutTipoUsuarioInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutTipoUsuarioInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutTipoUsuarioInput, UsuarioUncheckedUpdateWithoutTipoUsuarioInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutTipoUsuarioInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutTipoUsuarioInput>
  }

  export type EscolaCreateWithoutUsuarioInput = {
    nomeEscola: string
    Turma?: TurmaCreateNestedManyWithoutEscolaInput
  }

  export type EscolaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nomeEscola: string
    Turma?: TurmaUncheckedCreateNestedManyWithoutEscolaInput
  }

  export type EscolaCreateOrConnectWithoutUsuarioInput = {
    where: EscolaWhereUniqueInput
    create: XOR<EscolaCreateWithoutUsuarioInput, EscolaUncheckedCreateWithoutUsuarioInput>
  }

  export type tipoUsuarioCreateWithoutUsuarioInput = {
    tipoUsuario: string
  }

  export type tipoUsuarioUncheckedCreateWithoutUsuarioInput = {
    id?: number
    tipoUsuario: string
  }

  export type tipoUsuarioCreateOrConnectWithoutUsuarioInput = {
    where: tipoUsuarioWhereUniqueInput
    create: XOR<tipoUsuarioCreateWithoutUsuarioInput, tipoUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type TurmaCreateWithoutUsuarioInput = {
    ano: number
    nomeTurma: string
    escola: EscolaCreateNestedOneWithoutTurmaInput
  }

  export type TurmaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    ano: number
    nomeTurma: string
    codEscola: number
  }

  export type TurmaCreateOrConnectWithoutUsuarioInput = {
    where: TurmaWhereUniqueInput
    create: XOR<TurmaCreateWithoutUsuarioInput, TurmaUncheckedCreateWithoutUsuarioInput>
  }

  export type EntregaCreateWithoutAlunoInput = {
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    atividade: AtividadeCreateNestedOneWithoutEntregaInput
    Correcao?: CorrecaoCreateNestedOneWithoutEntregaInput
  }

  export type EntregaUncheckedCreateWithoutAlunoInput = {
    id?: number
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    codAtividade: number
    Correcao?: CorrecaoUncheckedCreateNestedOneWithoutEntregaInput
  }

  export type EntregaCreateOrConnectWithoutAlunoInput = {
    where: EntregaWhereUniqueInput
    create: XOR<EntregaCreateWithoutAlunoInput, EntregaUncheckedCreateWithoutAlunoInput>
  }

  export type EntregaCreateManyAlunoInputEnvelope = {
    data: EntregaCreateManyAlunoInput | EntregaCreateManyAlunoInput[]
    skipDuplicates?: boolean
  }

  export type SolicitacaoSuporteCreateWithoutAlunoInput = {
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
    Resposta?: RespostaCreateNestedOneWithoutSolicitacaoSuporteInput
  }

  export type SolicitacaoSuporteUncheckedCreateWithoutAlunoInput = {
    id?: number
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
    Resposta?: RespostaUncheckedCreateNestedOneWithoutSolicitacaoSuporteInput
  }

  export type SolicitacaoSuporteCreateOrConnectWithoutAlunoInput = {
    where: SolicitacaoSuporteWhereUniqueInput
    create: XOR<SolicitacaoSuporteCreateWithoutAlunoInput, SolicitacaoSuporteUncheckedCreateWithoutAlunoInput>
  }

  export type SolicitacaoSuporteCreateManyAlunoInputEnvelope = {
    data: SolicitacaoSuporteCreateManyAlunoInput | SolicitacaoSuporteCreateManyAlunoInput[]
    skipDuplicates?: boolean
  }

  export type RespostaCreateWithoutCoordenadorInput = {
    dataResposta?: Date | string
    resposta: string
    solicitacaoSuporte: SolicitacaoSuporteCreateNestedOneWithoutRespostaInput
  }

  export type RespostaUncheckedCreateWithoutCoordenadorInput = {
    id?: number
    dataResposta?: Date | string
    resposta: string
    codSolicitacao: number
  }

  export type RespostaCreateOrConnectWithoutCoordenadorInput = {
    where: RespostaWhereUniqueInput
    create: XOR<RespostaCreateWithoutCoordenadorInput, RespostaUncheckedCreateWithoutCoordenadorInput>
  }

  export type RespostaCreateManyCoordenadorInputEnvelope = {
    data: RespostaCreateManyCoordenadorInput | RespostaCreateManyCoordenadorInput[]
    skipDuplicates?: boolean
  }

  export type CorrecaoCreateWithoutCoordenadorInput = {
    dataCorrecao?: Date | string
    conteudo: string
    entrega: EntregaCreateNestedOneWithoutCorrecaoInput
  }

  export type CorrecaoUncheckedCreateWithoutCoordenadorInput = {
    id?: number
    dataCorrecao?: Date | string
    conteudo: string
    codEntrega: number
  }

  export type CorrecaoCreateOrConnectWithoutCoordenadorInput = {
    where: CorrecaoWhereUniqueInput
    create: XOR<CorrecaoCreateWithoutCoordenadorInput, CorrecaoUncheckedCreateWithoutCoordenadorInput>
  }

  export type CorrecaoCreateManyCoordenadorInputEnvelope = {
    data: CorrecaoCreateManyCoordenadorInput | CorrecaoCreateManyCoordenadorInput[]
    skipDuplicates?: boolean
  }

  export type HorasCreateWithoutAlunoInput = {
    horasAnuais: number
    horasConcluidas: number
    ano: number
  }

  export type HorasUncheckedCreateWithoutAlunoInput = {
    id?: number
    horasAnuais: number
    horasConcluidas: number
    ano: number
  }

  export type HorasCreateOrConnectWithoutAlunoInput = {
    where: HorasWhereUniqueInput
    create: XOR<HorasCreateWithoutAlunoInput, HorasUncheckedCreateWithoutAlunoInput>
  }

  export type HorasCreateManyAlunoInputEnvelope = {
    data: HorasCreateManyAlunoInput | HorasCreateManyAlunoInput[]
    skipDuplicates?: boolean
  }

  export type EscolaUpsertWithoutUsuarioInput = {
    update: XOR<EscolaUpdateWithoutUsuarioInput, EscolaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EscolaCreateWithoutUsuarioInput, EscolaUncheckedCreateWithoutUsuarioInput>
    where?: EscolaWhereInput
  }

  export type EscolaUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: EscolaWhereInput
    data: XOR<EscolaUpdateWithoutUsuarioInput, EscolaUncheckedUpdateWithoutUsuarioInput>
  }

  export type EscolaUpdateWithoutUsuarioInput = {
    nomeEscola?: StringFieldUpdateOperationsInput | string
    Turma?: TurmaUpdateManyWithoutEscolaNestedInput
  }

  export type EscolaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    Turma?: TurmaUncheckedUpdateManyWithoutEscolaNestedInput
  }

  export type tipoUsuarioUpsertWithoutUsuarioInput = {
    update: XOR<tipoUsuarioUpdateWithoutUsuarioInput, tipoUsuarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<tipoUsuarioCreateWithoutUsuarioInput, tipoUsuarioUncheckedCreateWithoutUsuarioInput>
    where?: tipoUsuarioWhereInput
  }

  export type tipoUsuarioUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: tipoUsuarioWhereInput
    data: XOR<tipoUsuarioUpdateWithoutUsuarioInput, tipoUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type tipoUsuarioUpdateWithoutUsuarioInput = {
    tipoUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type tipoUsuarioUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoUsuario?: StringFieldUpdateOperationsInput | string
  }

  export type TurmaUpsertWithoutUsuarioInput = {
    update: XOR<TurmaUpdateWithoutUsuarioInput, TurmaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TurmaCreateWithoutUsuarioInput, TurmaUncheckedCreateWithoutUsuarioInput>
    where?: TurmaWhereInput
  }

  export type TurmaUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: TurmaWhereInput
    data: XOR<TurmaUpdateWithoutUsuarioInput, TurmaUncheckedUpdateWithoutUsuarioInput>
  }

  export type TurmaUpdateWithoutUsuarioInput = {
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
    escola?: EscolaUpdateOneRequiredWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
    codEscola?: IntFieldUpdateOperationsInput | number
  }

  export type EntregaUpsertWithWhereUniqueWithoutAlunoInput = {
    where: EntregaWhereUniqueInput
    update: XOR<EntregaUpdateWithoutAlunoInput, EntregaUncheckedUpdateWithoutAlunoInput>
    create: XOR<EntregaCreateWithoutAlunoInput, EntregaUncheckedCreateWithoutAlunoInput>
  }

  export type EntregaUpdateWithWhereUniqueWithoutAlunoInput = {
    where: EntregaWhereUniqueInput
    data: XOR<EntregaUpdateWithoutAlunoInput, EntregaUncheckedUpdateWithoutAlunoInput>
  }

  export type EntregaUpdateManyWithWhereWithoutAlunoInput = {
    where: EntregaScalarWhereInput
    data: XOR<EntregaUpdateManyMutationInput, EntregaUncheckedUpdateManyWithoutAlunoInput>
  }

  export type EntregaScalarWhereInput = {
    AND?: EntregaScalarWhereInput | EntregaScalarWhereInput[]
    OR?: EntregaScalarWhereInput[]
    NOT?: EntregaScalarWhereInput | EntregaScalarWhereInput[]
    id?: IntFilter<"Entrega"> | number
    dataEntrega?: DateTimeNullableFilter<"Entrega"> | Date | string | null
    conteudo?: StringNullableFilter<"Entrega"> | string | null
    entregue?: BoolFilter<"Entrega"> | boolean
    codAluno?: IntFilter<"Entrega"> | number
    codAtividade?: IntFilter<"Entrega"> | number
  }

  export type SolicitacaoSuporteUpsertWithWhereUniqueWithoutAlunoInput = {
    where: SolicitacaoSuporteWhereUniqueInput
    update: XOR<SolicitacaoSuporteUpdateWithoutAlunoInput, SolicitacaoSuporteUncheckedUpdateWithoutAlunoInput>
    create: XOR<SolicitacaoSuporteCreateWithoutAlunoInput, SolicitacaoSuporteUncheckedCreateWithoutAlunoInput>
  }

  export type SolicitacaoSuporteUpdateWithWhereUniqueWithoutAlunoInput = {
    where: SolicitacaoSuporteWhereUniqueInput
    data: XOR<SolicitacaoSuporteUpdateWithoutAlunoInput, SolicitacaoSuporteUncheckedUpdateWithoutAlunoInput>
  }

  export type SolicitacaoSuporteUpdateManyWithWhereWithoutAlunoInput = {
    where: SolicitacaoSuporteScalarWhereInput
    data: XOR<SolicitacaoSuporteUpdateManyMutationInput, SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoInput>
  }

  export type SolicitacaoSuporteScalarWhereInput = {
    AND?: SolicitacaoSuporteScalarWhereInput | SolicitacaoSuporteScalarWhereInput[]
    OR?: SolicitacaoSuporteScalarWhereInput[]
    NOT?: SolicitacaoSuporteScalarWhereInput | SolicitacaoSuporteScalarWhereInput[]
    id?: IntFilter<"SolicitacaoSuporte"> | number
    titulo?: StringFilter<"SolicitacaoSuporte"> | string
    conteudo?: StringFilter<"SolicitacaoSuporte"> | string
    dataCriacao?: DateTimeFilter<"SolicitacaoSuporte"> | Date | string
    codAluno?: IntFilter<"SolicitacaoSuporte"> | number
  }

  export type RespostaUpsertWithWhereUniqueWithoutCoordenadorInput = {
    where: RespostaWhereUniqueInput
    update: XOR<RespostaUpdateWithoutCoordenadorInput, RespostaUncheckedUpdateWithoutCoordenadorInput>
    create: XOR<RespostaCreateWithoutCoordenadorInput, RespostaUncheckedCreateWithoutCoordenadorInput>
  }

  export type RespostaUpdateWithWhereUniqueWithoutCoordenadorInput = {
    where: RespostaWhereUniqueInput
    data: XOR<RespostaUpdateWithoutCoordenadorInput, RespostaUncheckedUpdateWithoutCoordenadorInput>
  }

  export type RespostaUpdateManyWithWhereWithoutCoordenadorInput = {
    where: RespostaScalarWhereInput
    data: XOR<RespostaUpdateManyMutationInput, RespostaUncheckedUpdateManyWithoutCoordenadorInput>
  }

  export type RespostaScalarWhereInput = {
    AND?: RespostaScalarWhereInput | RespostaScalarWhereInput[]
    OR?: RespostaScalarWhereInput[]
    NOT?: RespostaScalarWhereInput | RespostaScalarWhereInput[]
    id?: IntFilter<"Resposta"> | number
    dataResposta?: DateTimeFilter<"Resposta"> | Date | string
    resposta?: StringFilter<"Resposta"> | string
    codCoordenador?: IntFilter<"Resposta"> | number
    codSolicitacao?: IntFilter<"Resposta"> | number
  }

  export type CorrecaoUpsertWithWhereUniqueWithoutCoordenadorInput = {
    where: CorrecaoWhereUniqueInput
    update: XOR<CorrecaoUpdateWithoutCoordenadorInput, CorrecaoUncheckedUpdateWithoutCoordenadorInput>
    create: XOR<CorrecaoCreateWithoutCoordenadorInput, CorrecaoUncheckedCreateWithoutCoordenadorInput>
  }

  export type CorrecaoUpdateWithWhereUniqueWithoutCoordenadorInput = {
    where: CorrecaoWhereUniqueInput
    data: XOR<CorrecaoUpdateWithoutCoordenadorInput, CorrecaoUncheckedUpdateWithoutCoordenadorInput>
  }

  export type CorrecaoUpdateManyWithWhereWithoutCoordenadorInput = {
    where: CorrecaoScalarWhereInput
    data: XOR<CorrecaoUpdateManyMutationInput, CorrecaoUncheckedUpdateManyWithoutCoordenadorInput>
  }

  export type CorrecaoScalarWhereInput = {
    AND?: CorrecaoScalarWhereInput | CorrecaoScalarWhereInput[]
    OR?: CorrecaoScalarWhereInput[]
    NOT?: CorrecaoScalarWhereInput | CorrecaoScalarWhereInput[]
    id?: IntFilter<"Correcao"> | number
    dataCorrecao?: DateTimeFilter<"Correcao"> | Date | string
    conteudo?: StringFilter<"Correcao"> | string
    codCoordenador?: IntFilter<"Correcao"> | number
    codEntrega?: IntFilter<"Correcao"> | number
  }

  export type HorasUpsertWithWhereUniqueWithoutAlunoInput = {
    where: HorasWhereUniqueInput
    update: XOR<HorasUpdateWithoutAlunoInput, HorasUncheckedUpdateWithoutAlunoInput>
    create: XOR<HorasCreateWithoutAlunoInput, HorasUncheckedCreateWithoutAlunoInput>
  }

  export type HorasUpdateWithWhereUniqueWithoutAlunoInput = {
    where: HorasWhereUniqueInput
    data: XOR<HorasUpdateWithoutAlunoInput, HorasUncheckedUpdateWithoutAlunoInput>
  }

  export type HorasUpdateManyWithWhereWithoutAlunoInput = {
    where: HorasScalarWhereInput
    data: XOR<HorasUpdateManyMutationInput, HorasUncheckedUpdateManyWithoutAlunoInput>
  }

  export type HorasScalarWhereInput = {
    AND?: HorasScalarWhereInput | HorasScalarWhereInput[]
    OR?: HorasScalarWhereInput[]
    NOT?: HorasScalarWhereInput | HorasScalarWhereInput[]
    id?: IntFilter<"Horas"> | number
    horasAnuais?: IntFilter<"Horas"> | number
    horasConcluidas?: IntFilter<"Horas"> | number
    ano?: IntFilter<"Horas"> | number
    codAluno?: IntFilter<"Horas"> | number
  }

  export type tipoAtividadeCreateWithoutAtividadeInput = {
    tipoAtividade: string
  }

  export type tipoAtividadeUncheckedCreateWithoutAtividadeInput = {
    id?: number
    tipoAtividade: string
  }

  export type tipoAtividadeCreateOrConnectWithoutAtividadeInput = {
    where: tipoAtividadeWhereUniqueInput
    create: XOR<tipoAtividadeCreateWithoutAtividadeInput, tipoAtividadeUncheckedCreateWithoutAtividadeInput>
  }

  export type EntregaCreateWithoutAtividadeInput = {
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    aluno: UsuarioCreateNestedOneWithoutEntregaInput
    Correcao?: CorrecaoCreateNestedOneWithoutEntregaInput
  }

  export type EntregaUncheckedCreateWithoutAtividadeInput = {
    id?: number
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    codAluno: number
    Correcao?: CorrecaoUncheckedCreateNestedOneWithoutEntregaInput
  }

  export type EntregaCreateOrConnectWithoutAtividadeInput = {
    where: EntregaWhereUniqueInput
    create: XOR<EntregaCreateWithoutAtividadeInput, EntregaUncheckedCreateWithoutAtividadeInput>
  }

  export type EntregaCreateManyAtividadeInputEnvelope = {
    data: EntregaCreateManyAtividadeInput | EntregaCreateManyAtividadeInput[]
    skipDuplicates?: boolean
  }

  export type tipoAtividadeUpsertWithoutAtividadeInput = {
    update: XOR<tipoAtividadeUpdateWithoutAtividadeInput, tipoAtividadeUncheckedUpdateWithoutAtividadeInput>
    create: XOR<tipoAtividadeCreateWithoutAtividadeInput, tipoAtividadeUncheckedCreateWithoutAtividadeInput>
    where?: tipoAtividadeWhereInput
  }

  export type tipoAtividadeUpdateToOneWithWhereWithoutAtividadeInput = {
    where?: tipoAtividadeWhereInput
    data: XOR<tipoAtividadeUpdateWithoutAtividadeInput, tipoAtividadeUncheckedUpdateWithoutAtividadeInput>
  }

  export type tipoAtividadeUpdateWithoutAtividadeInput = {
    tipoAtividade?: StringFieldUpdateOperationsInput | string
  }

  export type tipoAtividadeUncheckedUpdateWithoutAtividadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAtividade?: StringFieldUpdateOperationsInput | string
  }

  export type EntregaUpsertWithWhereUniqueWithoutAtividadeInput = {
    where: EntregaWhereUniqueInput
    update: XOR<EntregaUpdateWithoutAtividadeInput, EntregaUncheckedUpdateWithoutAtividadeInput>
    create: XOR<EntregaCreateWithoutAtividadeInput, EntregaUncheckedCreateWithoutAtividadeInput>
  }

  export type EntregaUpdateWithWhereUniqueWithoutAtividadeInput = {
    where: EntregaWhereUniqueInput
    data: XOR<EntregaUpdateWithoutAtividadeInput, EntregaUncheckedUpdateWithoutAtividadeInput>
  }

  export type EntregaUpdateManyWithWhereWithoutAtividadeInput = {
    where: EntregaScalarWhereInput
    data: XOR<EntregaUpdateManyMutationInput, EntregaUncheckedUpdateManyWithoutAtividadeInput>
  }

  export type AtividadeCreateWithoutTipoAtividadeInput = {
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
    entrega?: EntregaCreateNestedManyWithoutAtividadeInput
  }

  export type AtividadeUncheckedCreateWithoutTipoAtividadeInput = {
    id?: number
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
    entrega?: EntregaUncheckedCreateNestedManyWithoutAtividadeInput
  }

  export type AtividadeCreateOrConnectWithoutTipoAtividadeInput = {
    where: AtividadeWhereUniqueInput
    create: XOR<AtividadeCreateWithoutTipoAtividadeInput, AtividadeUncheckedCreateWithoutTipoAtividadeInput>
  }

  export type AtividadeCreateManyTipoAtividadeInputEnvelope = {
    data: AtividadeCreateManyTipoAtividadeInput | AtividadeCreateManyTipoAtividadeInput[]
    skipDuplicates?: boolean
  }

  export type AtividadeUpsertWithWhereUniqueWithoutTipoAtividadeInput = {
    where: AtividadeWhereUniqueInput
    update: XOR<AtividadeUpdateWithoutTipoAtividadeInput, AtividadeUncheckedUpdateWithoutTipoAtividadeInput>
    create: XOR<AtividadeCreateWithoutTipoAtividadeInput, AtividadeUncheckedCreateWithoutTipoAtividadeInput>
  }

  export type AtividadeUpdateWithWhereUniqueWithoutTipoAtividadeInput = {
    where: AtividadeWhereUniqueInput
    data: XOR<AtividadeUpdateWithoutTipoAtividadeInput, AtividadeUncheckedUpdateWithoutTipoAtividadeInput>
  }

  export type AtividadeUpdateManyWithWhereWithoutTipoAtividadeInput = {
    where: AtividadeScalarWhereInput
    data: XOR<AtividadeUpdateManyMutationInput, AtividadeUncheckedUpdateManyWithoutTipoAtividadeInput>
  }

  export type AtividadeScalarWhereInput = {
    AND?: AtividadeScalarWhereInput | AtividadeScalarWhereInput[]
    OR?: AtividadeScalarWhereInput[]
    NOT?: AtividadeScalarWhereInput | AtividadeScalarWhereInput[]
    id?: IntFilter<"Atividade"> | number
    titulo?: StringFilter<"Atividade"> | string
    descricao?: StringFilter<"Atividade"> | string
    anexos?: StringNullableFilter<"Atividade"> | string | null
    horasAtividade?: IntFilter<"Atividade"> | number
    dataCriacao?: DateTimeFilter<"Atividade"> | Date | string
    prazoEntrega?: DateTimeFilter<"Atividade"> | Date | string
    codTipoAtividade?: IntFilter<"Atividade"> | number
  }

  export type UsuarioCreateWithoutEntregaInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateWithoutEntregaInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    codTurma?: number | null
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioCreateOrConnectWithoutEntregaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEntregaInput, UsuarioUncheckedCreateWithoutEntregaInput>
  }

  export type AtividadeCreateWithoutEntregaInput = {
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
    tipoAtividade: tipoAtividadeCreateNestedOneWithoutAtividadeInput
  }

  export type AtividadeUncheckedCreateWithoutEntregaInput = {
    id?: number
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
    codTipoAtividade: number
  }

  export type AtividadeCreateOrConnectWithoutEntregaInput = {
    where: AtividadeWhereUniqueInput
    create: XOR<AtividadeCreateWithoutEntregaInput, AtividadeUncheckedCreateWithoutEntregaInput>
  }

  export type CorrecaoCreateWithoutEntregaInput = {
    dataCorrecao?: Date | string
    conteudo: string
    coordenador: UsuarioCreateNestedOneWithoutCorrecaoInput
  }

  export type CorrecaoUncheckedCreateWithoutEntregaInput = {
    id?: number
    dataCorrecao?: Date | string
    conteudo: string
    codCoordenador: number
  }

  export type CorrecaoCreateOrConnectWithoutEntregaInput = {
    where: CorrecaoWhereUniqueInput
    create: XOR<CorrecaoCreateWithoutEntregaInput, CorrecaoUncheckedCreateWithoutEntregaInput>
  }

  export type UsuarioUpsertWithoutEntregaInput = {
    update: XOR<UsuarioUpdateWithoutEntregaInput, UsuarioUncheckedUpdateWithoutEntregaInput>
    create: XOR<UsuarioCreateWithoutEntregaInput, UsuarioUncheckedCreateWithoutEntregaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEntregaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEntregaInput, UsuarioUncheckedUpdateWithoutEntregaInput>
  }

  export type UsuarioUpdateWithoutEntregaInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEntregaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type AtividadeUpsertWithoutEntregaInput = {
    update: XOR<AtividadeUpdateWithoutEntregaInput, AtividadeUncheckedUpdateWithoutEntregaInput>
    create: XOR<AtividadeCreateWithoutEntregaInput, AtividadeUncheckedCreateWithoutEntregaInput>
    where?: AtividadeWhereInput
  }

  export type AtividadeUpdateToOneWithWhereWithoutEntregaInput = {
    where?: AtividadeWhereInput
    data: XOR<AtividadeUpdateWithoutEntregaInput, AtividadeUncheckedUpdateWithoutEntregaInput>
  }

  export type AtividadeUpdateWithoutEntregaInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoAtividade?: tipoAtividadeUpdateOneRequiredWithoutAtividadeNestedInput
  }

  export type AtividadeUncheckedUpdateWithoutEntregaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    codTipoAtividade?: IntFieldUpdateOperationsInput | number
  }

  export type CorrecaoUpsertWithoutEntregaInput = {
    update: XOR<CorrecaoUpdateWithoutEntregaInput, CorrecaoUncheckedUpdateWithoutEntregaInput>
    create: XOR<CorrecaoCreateWithoutEntregaInput, CorrecaoUncheckedCreateWithoutEntregaInput>
    where?: CorrecaoWhereInput
  }

  export type CorrecaoUpdateToOneWithWhereWithoutEntregaInput = {
    where?: CorrecaoWhereInput
    data: XOR<CorrecaoUpdateWithoutEntregaInput, CorrecaoUncheckedUpdateWithoutEntregaInput>
  }

  export type CorrecaoUpdateWithoutEntregaInput = {
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    coordenador?: UsuarioUpdateOneRequiredWithoutCorrecaoNestedInput
  }

  export type CorrecaoUncheckedUpdateWithoutEntregaInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    codCoordenador?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateWithoutSolicitacaoSuporteInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateWithoutSolicitacaoSuporteInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    codTurma?: number | null
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioCreateOrConnectWithoutSolicitacaoSuporteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutSolicitacaoSuporteInput, UsuarioUncheckedCreateWithoutSolicitacaoSuporteInput>
  }

  export type RespostaCreateWithoutSolicitacaoSuporteInput = {
    dataResposta?: Date | string
    resposta: string
    coordenador: UsuarioCreateNestedOneWithoutRespostaInput
  }

  export type RespostaUncheckedCreateWithoutSolicitacaoSuporteInput = {
    id?: number
    dataResposta?: Date | string
    resposta: string
    codCoordenador: number
  }

  export type RespostaCreateOrConnectWithoutSolicitacaoSuporteInput = {
    where: RespostaWhereUniqueInput
    create: XOR<RespostaCreateWithoutSolicitacaoSuporteInput, RespostaUncheckedCreateWithoutSolicitacaoSuporteInput>
  }

  export type UsuarioUpsertWithoutSolicitacaoSuporteInput = {
    update: XOR<UsuarioUpdateWithoutSolicitacaoSuporteInput, UsuarioUncheckedUpdateWithoutSolicitacaoSuporteInput>
    create: XOR<UsuarioCreateWithoutSolicitacaoSuporteInput, UsuarioUncheckedCreateWithoutSolicitacaoSuporteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutSolicitacaoSuporteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutSolicitacaoSuporteInput, UsuarioUncheckedUpdateWithoutSolicitacaoSuporteInput>
  }

  export type UsuarioUpdateWithoutSolicitacaoSuporteInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutSolicitacaoSuporteInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type RespostaUpsertWithoutSolicitacaoSuporteInput = {
    update: XOR<RespostaUpdateWithoutSolicitacaoSuporteInput, RespostaUncheckedUpdateWithoutSolicitacaoSuporteInput>
    create: XOR<RespostaCreateWithoutSolicitacaoSuporteInput, RespostaUncheckedCreateWithoutSolicitacaoSuporteInput>
    where?: RespostaWhereInput
  }

  export type RespostaUpdateToOneWithWhereWithoutSolicitacaoSuporteInput = {
    where?: RespostaWhereInput
    data: XOR<RespostaUpdateWithoutSolicitacaoSuporteInput, RespostaUncheckedUpdateWithoutSolicitacaoSuporteInput>
  }

  export type RespostaUpdateWithoutSolicitacaoSuporteInput = {
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    coordenador?: UsuarioUpdateOneRequiredWithoutRespostaNestedInput
  }

  export type RespostaUncheckedUpdateWithoutSolicitacaoSuporteInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    codCoordenador?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateWithoutRespostaInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateWithoutRespostaInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    codTurma?: number | null
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioCreateOrConnectWithoutRespostaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRespostaInput, UsuarioUncheckedCreateWithoutRespostaInput>
  }

  export type SolicitacaoSuporteCreateWithoutRespostaInput = {
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
    aluno: UsuarioCreateNestedOneWithoutSolicitacaoSuporteInput
  }

  export type SolicitacaoSuporteUncheckedCreateWithoutRespostaInput = {
    id?: number
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
    codAluno: number
  }

  export type SolicitacaoSuporteCreateOrConnectWithoutRespostaInput = {
    where: SolicitacaoSuporteWhereUniqueInput
    create: XOR<SolicitacaoSuporteCreateWithoutRespostaInput, SolicitacaoSuporteUncheckedCreateWithoutRespostaInput>
  }

  export type UsuarioUpsertWithoutRespostaInput = {
    update: XOR<UsuarioUpdateWithoutRespostaInput, UsuarioUncheckedUpdateWithoutRespostaInput>
    create: XOR<UsuarioCreateWithoutRespostaInput, UsuarioUncheckedCreateWithoutRespostaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRespostaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRespostaInput, UsuarioUncheckedUpdateWithoutRespostaInput>
  }

  export type UsuarioUpdateWithoutRespostaInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRespostaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type SolicitacaoSuporteUpsertWithoutRespostaInput = {
    update: XOR<SolicitacaoSuporteUpdateWithoutRespostaInput, SolicitacaoSuporteUncheckedUpdateWithoutRespostaInput>
    create: XOR<SolicitacaoSuporteCreateWithoutRespostaInput, SolicitacaoSuporteUncheckedCreateWithoutRespostaInput>
    where?: SolicitacaoSuporteWhereInput
  }

  export type SolicitacaoSuporteUpdateToOneWithWhereWithoutRespostaInput = {
    where?: SolicitacaoSuporteWhereInput
    data: XOR<SolicitacaoSuporteUpdateWithoutRespostaInput, SolicitacaoSuporteUncheckedUpdateWithoutRespostaInput>
  }

  export type SolicitacaoSuporteUpdateWithoutRespostaInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    aluno?: UsuarioUpdateOneRequiredWithoutSolicitacaoSuporteNestedInput
  }

  export type SolicitacaoSuporteUncheckedUpdateWithoutRespostaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    codAluno?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateWithoutCorrecaoInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioUncheckedCreateWithoutCorrecaoInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    codTurma?: number | null
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Horas?: HorasUncheckedCreateNestedManyWithoutAlunoInput
  }

  export type UsuarioCreateOrConnectWithoutCorrecaoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCorrecaoInput, UsuarioUncheckedCreateWithoutCorrecaoInput>
  }

  export type EntregaCreateWithoutCorrecaoInput = {
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    aluno: UsuarioCreateNestedOneWithoutEntregaInput
    atividade: AtividadeCreateNestedOneWithoutEntregaInput
  }

  export type EntregaUncheckedCreateWithoutCorrecaoInput = {
    id?: number
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    codAluno: number
    codAtividade: number
  }

  export type EntregaCreateOrConnectWithoutCorrecaoInput = {
    where: EntregaWhereUniqueInput
    create: XOR<EntregaCreateWithoutCorrecaoInput, EntregaUncheckedCreateWithoutCorrecaoInput>
  }

  export type UsuarioUpsertWithoutCorrecaoInput = {
    update: XOR<UsuarioUpdateWithoutCorrecaoInput, UsuarioUncheckedUpdateWithoutCorrecaoInput>
    create: XOR<UsuarioCreateWithoutCorrecaoInput, UsuarioUncheckedCreateWithoutCorrecaoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCorrecaoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCorrecaoInput, UsuarioUncheckedUpdateWithoutCorrecaoInput>
  }

  export type UsuarioUpdateWithoutCorrecaoInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCorrecaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type EntregaUpsertWithoutCorrecaoInput = {
    update: XOR<EntregaUpdateWithoutCorrecaoInput, EntregaUncheckedUpdateWithoutCorrecaoInput>
    create: XOR<EntregaCreateWithoutCorrecaoInput, EntregaUncheckedCreateWithoutCorrecaoInput>
    where?: EntregaWhereInput
  }

  export type EntregaUpdateToOneWithWhereWithoutCorrecaoInput = {
    where?: EntregaWhereInput
    data: XOR<EntregaUpdateWithoutCorrecaoInput, EntregaUncheckedUpdateWithoutCorrecaoInput>
  }

  export type EntregaUpdateWithoutCorrecaoInput = {
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    aluno?: UsuarioUpdateOneRequiredWithoutEntregaNestedInput
    atividade?: AtividadeUpdateOneRequiredWithoutEntregaNestedInput
  }

  export type EntregaUncheckedUpdateWithoutCorrecaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    codAluno?: IntFieldUpdateOperationsInput | number
    codAtividade?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateWithoutHorasInput = {
    email: string
    senha: string
    nome: string
    rm?: number | null
    escolaRel?: EscolaCreateNestedOneWithoutUsuarioInput
    tipoUsuario: tipoUsuarioCreateNestedOneWithoutUsuarioInput
    turma?: TurmaCreateNestedOneWithoutUsuarioInput
    Entrega?: EntregaCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoCreateNestedManyWithoutCoordenadorInput
  }

  export type UsuarioUncheckedCreateWithoutHorasInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
    codTurma?: number | null
    Entrega?: EntregaUncheckedCreateNestedManyWithoutAlunoInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedCreateNestedManyWithoutAlunoInput
    Resposta?: RespostaUncheckedCreateNestedManyWithoutCoordenadorInput
    Correcao?: CorrecaoUncheckedCreateNestedManyWithoutCoordenadorInput
  }

  export type UsuarioCreateOrConnectWithoutHorasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutHorasInput, UsuarioUncheckedCreateWithoutHorasInput>
  }

  export type UsuarioUpsertWithoutHorasInput = {
    update: XOR<UsuarioUpdateWithoutHorasInput, UsuarioUncheckedUpdateWithoutHorasInput>
    create: XOR<UsuarioCreateWithoutHorasInput, UsuarioUncheckedCreateWithoutHorasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutHorasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutHorasInput, UsuarioUncheckedUpdateWithoutHorasInput>
  }

  export type UsuarioUpdateWithoutHorasInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutHorasInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
  }

  export type UsuarioCreateManyEscolaRelInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codTipoUsuario: number
    codTurma?: number | null
  }

  export type TurmaCreateManyEscolaInput = {
    id?: number
    ano: number
    nomeTurma: string
  }

  export type UsuarioUpdateWithoutEscolaRelInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEscolaRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutEscolaRelInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TurmaUpdateWithoutEscolaInput = {
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateWithoutEscolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUncheckedUpdateManyWithoutTurmaNestedInput
  }

  export type TurmaUncheckedUpdateManyWithoutEscolaInput = {
    id?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    nomeTurma?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateManyTurmaInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTipoUsuario: number
  }

  export type UsuarioUpdateWithoutTurmaInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    tipoUsuario?: tipoUsuarioUpdateOneRequiredWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutTurmaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTipoUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateManyTipoUsuarioInput = {
    id?: number
    email: string
    senha: string
    nome: string
    rm?: number | null
    codEscola?: number | null
    codTurma?: number | null
  }

  export type UsuarioUpdateWithoutTipoUsuarioInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    escolaRel?: EscolaUpdateOneWithoutUsuarioNestedInput
    turma?: TurmaUpdateOneWithoutUsuarioNestedInput
    Entrega?: EntregaUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTipoUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
    Entrega?: EntregaUncheckedUpdateManyWithoutAlunoNestedInput
    SolicitacaoSuporte?: SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoNestedInput
    Resposta?: RespostaUncheckedUpdateManyWithoutCoordenadorNestedInput
    Correcao?: CorrecaoUncheckedUpdateManyWithoutCoordenadorNestedInput
    Horas?: HorasUncheckedUpdateManyWithoutAlunoNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutTipoUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    rm?: NullableIntFieldUpdateOperationsInput | number | null
    codEscola?: NullableIntFieldUpdateOperationsInput | number | null
    codTurma?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EntregaCreateManyAlunoInput = {
    id?: number
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    codAtividade: number
  }

  export type SolicitacaoSuporteCreateManyAlunoInput = {
    id?: number
    titulo: string
    conteudo: string
    dataCriacao?: Date | string
  }

  export type RespostaCreateManyCoordenadorInput = {
    id?: number
    dataResposta?: Date | string
    resposta: string
    codSolicitacao: number
  }

  export type CorrecaoCreateManyCoordenadorInput = {
    id?: number
    dataCorrecao?: Date | string
    conteudo: string
    codEntrega: number
  }

  export type HorasCreateManyAlunoInput = {
    id?: number
    horasAnuais: number
    horasConcluidas: number
    ano: number
  }

  export type EntregaUpdateWithoutAlunoInput = {
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    atividade?: AtividadeUpdateOneRequiredWithoutEntregaNestedInput
    Correcao?: CorrecaoUpdateOneWithoutEntregaNestedInput
  }

  export type EntregaUncheckedUpdateWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    codAtividade?: IntFieldUpdateOperationsInput | number
    Correcao?: CorrecaoUncheckedUpdateOneWithoutEntregaNestedInput
  }

  export type EntregaUncheckedUpdateManyWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    codAtividade?: IntFieldUpdateOperationsInput | number
  }

  export type SolicitacaoSuporteUpdateWithoutAlunoInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    Resposta?: RespostaUpdateOneWithoutSolicitacaoSuporteNestedInput
  }

  export type SolicitacaoSuporteUncheckedUpdateWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    Resposta?: RespostaUncheckedUpdateOneWithoutSolicitacaoSuporteNestedInput
  }

  export type SolicitacaoSuporteUncheckedUpdateManyWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RespostaUpdateWithoutCoordenadorInput = {
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    solicitacaoSuporte?: SolicitacaoSuporteUpdateOneRequiredWithoutRespostaNestedInput
  }

  export type RespostaUncheckedUpdateWithoutCoordenadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    codSolicitacao?: IntFieldUpdateOperationsInput | number
  }

  export type RespostaUncheckedUpdateManyWithoutCoordenadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataResposta?: DateTimeFieldUpdateOperationsInput | Date | string
    resposta?: StringFieldUpdateOperationsInput | string
    codSolicitacao?: IntFieldUpdateOperationsInput | number
  }

  export type CorrecaoUpdateWithoutCoordenadorInput = {
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    entrega?: EntregaUpdateOneRequiredWithoutCorrecaoNestedInput
  }

  export type CorrecaoUncheckedUpdateWithoutCoordenadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    codEntrega?: IntFieldUpdateOperationsInput | number
  }

  export type CorrecaoUncheckedUpdateManyWithoutCoordenadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataCorrecao?: DateTimeFieldUpdateOperationsInput | Date | string
    conteudo?: StringFieldUpdateOperationsInput | string
    codEntrega?: IntFieldUpdateOperationsInput | number
  }

  export type HorasUpdateWithoutAlunoInput = {
    horasAnuais?: IntFieldUpdateOperationsInput | number
    horasConcluidas?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type HorasUncheckedUpdateWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    horasAnuais?: IntFieldUpdateOperationsInput | number
    horasConcluidas?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type HorasUncheckedUpdateManyWithoutAlunoInput = {
    id?: IntFieldUpdateOperationsInput | number
    horasAnuais?: IntFieldUpdateOperationsInput | number
    horasConcluidas?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type EntregaCreateManyAtividadeInput = {
    id?: number
    dataEntrega?: Date | string | null
    conteudo?: string | null
    entregue?: boolean
    codAluno: number
  }

  export type EntregaUpdateWithoutAtividadeInput = {
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    aluno?: UsuarioUpdateOneRequiredWithoutEntregaNestedInput
    Correcao?: CorrecaoUpdateOneWithoutEntregaNestedInput
  }

  export type EntregaUncheckedUpdateWithoutAtividadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    codAluno?: IntFieldUpdateOperationsInput | number
    Correcao?: CorrecaoUncheckedUpdateOneWithoutEntregaNestedInput
  }

  export type EntregaUncheckedUpdateManyWithoutAtividadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    dataEntrega?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conteudo?: NullableStringFieldUpdateOperationsInput | string | null
    entregue?: BoolFieldUpdateOperationsInput | boolean
    codAluno?: IntFieldUpdateOperationsInput | number
  }

  export type AtividadeCreateManyTipoAtividadeInput = {
    id?: number
    titulo: string
    descricao: string
    anexos?: string | null
    horasAtividade: number
    dataCriacao?: Date | string
    prazoEntrega: Date | string
  }

  export type AtividadeUpdateWithoutTipoAtividadeInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    entrega?: EntregaUpdateManyWithoutAtividadeNestedInput
  }

  export type AtividadeUncheckedUpdateWithoutTipoAtividadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    entrega?: EntregaUncheckedUpdateManyWithoutAtividadeNestedInput
  }

  export type AtividadeUncheckedUpdateManyWithoutTipoAtividadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    anexos?: NullableStringFieldUpdateOperationsInput | string | null
    horasAtividade?: IntFieldUpdateOperationsInput | number
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    prazoEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use EscolaCountOutputTypeDefaultArgs instead
     */
    export type EscolaCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EscolaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TurmaCountOutputTypeDefaultArgs instead
     */
    export type TurmaCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TurmaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoUsuarioCountOutputTypeDefaultArgs instead
     */
    export type TipoUsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TipoUsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AtividadeCountOutputTypeDefaultArgs instead
     */
    export type AtividadeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AtividadeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoAtividadeCountOutputTypeDefaultArgs instead
     */
    export type TipoAtividadeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TipoAtividadeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EscolaDefaultArgs instead
     */
    export type EscolaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EscolaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TurmaDefaultArgs instead
     */
    export type TurmaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TurmaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tipoUsuarioDefaultArgs instead
     */
    export type tipoUsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = tipoUsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AtividadeDefaultArgs instead
     */
    export type AtividadeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AtividadeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tipoAtividadeDefaultArgs instead
     */
    export type tipoAtividadeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = tipoAtividadeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntregaDefaultArgs instead
     */
    export type EntregaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = EntregaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SolicitacaoSuporteDefaultArgs instead
     */
    export type SolicitacaoSuporteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SolicitacaoSuporteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RespostaDefaultArgs instead
     */
    export type RespostaArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = RespostaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CorrecaoDefaultArgs instead
     */
    export type CorrecaoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CorrecaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HorasDefaultArgs instead
     */
    export type HorasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = HorasDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}